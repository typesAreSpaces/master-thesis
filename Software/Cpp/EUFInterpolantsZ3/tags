!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
-log-file	Makefile	/^	valgrind --log-file="euf_interpolator.txt" .\/euf_interpolator$/;"	m
APPLY_EQ	include/CurryNode.h	/^enum KindEquation { CONST_EQ, APPLY_EQ  };$/;"	e	enum:KindEquation
CC	Makefile	/^CC = g++$/;"	m
CONST_EQ	include/CurryNode.h	/^enum KindEquation { CONST_EQ, APPLY_EQ  };$/;"	e	enum:KindEquation
ClassList	include/Hornsat.h	/^typedef std::vector<std::vector<ClassListPos> > ClassList;$/;"	t
ClassListPos	include/Hornsat.h	/^  ClassListPos(Literal * lit_pointer, SideOfEquation eq_side) :$/;"	f	struct:ClassListPos
ClassListPos	include/Hornsat.h	/^struct ClassListPos {$/;"	s
Clause	include/Hornsat.h	/^  Clause(unsigned id, struct Clause * clause) : clause_id(id), next(clause){}$/;"	f	struct:Clause
Clause	include/Hornsat.h	/^struct Clause {$/;"	s
CongruenceClosure	include/CongruenceClosure.h	/^class CongruenceClosure {$/;"	c
CongruenceClosure	src/CongruenceClosure.cpp	/^CongruenceClosure::CongruenceClosure(const Z3Subterms & subterms,$/;"	f	class:CongruenceClosure
CongruenceClosureDST	include/CongruenceClosureDST.h	/^class CongruenceClosureDST : public CongruenceClosure {$/;"	c
CongruenceClosureDST	src/CongruenceClosureDST.cpp	/^CongruenceClosureDST::CongruenceClosureDST(const Z3Subterms & subterms,$/;"	f	class:CongruenceClosureDST
CongruenceClosureExplain	include/CongruenceClosureExplain.h	/^class CongruenceClosureExplain : public CongruenceClosure {$/;"	c
CongruenceClosureExplain	src/CongruenceClosureExplain.cpp	/^CongruenceClosureExplain::CongruenceClosureExplain(const Z3Subterms & subterms,$/;"	f	class:CongruenceClosureExplain
CongruenceClosureNO	include/CongruenceClosureNO.h	/^class CongruenceClosureNO : public CongruenceClosure {$/;"	c
CongruenceClosureNO	src/CongruenceClosureNO.cpp	/^CongruenceClosureNO::CongruenceClosureNO(const Z3Subterms & subterms,$/;"	f	class:CongruenceClosureNO
CurryDeclarations	include/CurryNode.h	/^typedef std::map<unsigned, CurryNode*> CurryDeclarations;$/;"	t
CurryNode	include/CurryNode.h	/^class CurryNode {$/;"	c
CurryNode	src/CurryNode.cpp	/^CurryNode::CurryNode(unsigned id, std::string func_name, CurryNode * left, CurryNode * right) :$/;"	f	class:CurryNode
CurryPreds	include/CurryNode.h	/^typedef std::map<const CurryNode *, std::list<PredNode> > CurryPreds;$/;"	t
DEBUGGING_CONSTRUCTOR	src/Hornsat.cpp	4;"	d	file:
DEBUGGING_SATISFIABLE	src/Hornsat.cpp	2;"	d	file:
DEBUGGING_UNIONUPDATE	src/Hornsat.cpp	3;"	d	file:
DEBUG_ADDINGHC	src/HornClauses.cpp	3;"	d	file:
DEBUG_CE	src/HornClauses.cpp	5;"	d	file:
DEBUG_COMBINATION_HELPER	src/HornClauses.cpp	6;"	d	file:
DEBUG_CURRYFICATION	src/EUFInterpolant.cpp	4;"	d	file:
DEBUG_DESTRUCTORS	include/Hornsat.h	4;"	d
DEBUG_DESTRUCTORS_CC	include/CongruenceClosure.h	3;"	d
DEBUG_DESTRUCTOR_EUF	src/EUFInterpolant.cpp	2;"	d	file:
DEBUG_DESTRUCTOR_HC	src/HornClause.cpp	2;"	d	file:
DEBUG_DESTRUCTOR_HCS	src/HornClauses.cpp	8;"	d	file:
DEBUG_DESTRUCTOR_MATCH	src/Match.cpp	2;"	d	file:
DEBUG_DESTRUCTOR_UF	src/UnionFind.cpp	2;"	d	file:
DEBUG_DESTRUCTOR_UFE	src/UnionFindExplain.cpp	2;"	d	file:
DEBUG_EUFINTERPOLANT	src/EUFInterpolant.cpp	3;"	d	file:
DEBUG_EXPLAIN_OP	src/UnionFindExplain.cpp	3;"	d	file:
DEBUG_HORN_CLAUSES	src/HornClauses.cpp	2;"	d	file:
DEBUG_INIT	src/EUFInterpolant.cpp	6;"	d	file:
DEBUG_MAKE_MATCHES	src/HornClauses.cpp	4;"	d	file:
DEBUG_MATCHES	src/HornClauses.cpp	7;"	d	file:
DEBUG_MERGE	src/CongruenceClosureExplain.cpp	5;"	d	file:
DEBUG_PROPAGATE	src/CongruenceClosureExplain.cpp	6;"	d	file:
DEBUG_PROPAGATE_AUX	src/CongruenceClosureExplain.cpp	7;"	d	file:
DEBUG_SANITY_CHECK	src/CongruenceClosureExplain.cpp	4;"	d	file:
DEBUG_SUBTERMS	src/EUFInterpolant.cpp	5;"	d	file:
DEBUG_TEST_EXPLAIN	src/CongruenceClosureExplain.cpp	8;"	d	file:
DEPS	Makefile	/^DEPS = $(wildcard $(IDIR)\/*.h)$/;"	m
EQ	include/CurryNode.h	/^enum PendingTag { EQ, EQ_EQ };$/;"	e	enum:PendingTag
EQ_EQ	include/CurryNode.h	/^enum PendingTag { EQ, EQ_EQ };$/;"	e	enum:PendingTag
EUFInterpolant	include/EUFInterpolant.h	/^class EUFInterpolant {$/;"	c
EUFInterpolant	src/EUFInterpolant.cpp	/^EUFInterpolant::EUFInterpolant(z3::expr const & input_formula) :$/;"	f	class:EUFInterpolant
EqClass	include/UnionFind.h	/^typedef unsigned EqClass;$/;"	t
EqClass_hasher	include/CongruenceClosureExplain.h	/^  std::hash<EqClass> EqClass_hasher;$/;"	m	class:LookupTable
EquationCurryNodes	include/CurryNode.h	/^  EquationCurryNodes(CurryNode & lhs, CurryNode & rhs) :$/;"	f	struct:EquationCurryNodes
EquationCurryNodes	include/CurryNode.h	/^  EquationCurryNodes(CurryNode & lhs, CurryNode & rhs, KindEquation kind_equation) :$/;"	f	struct:EquationCurryNodes
EquationCurryNodes	include/CurryNode.h	/^struct EquationCurryNodes {$/;"	s
EquationZ3Ids	include/CurryNode.h	/^  EquationZ3Ids(unsigned lhs_id, unsigned rhs_id) :$/;"	f	struct:EquationZ3Ids
EquationZ3Ids	include/CurryNode.h	/^struct EquationZ3Ids {$/;"	s
ExplainEquation	include/UnionFindExplain.h	/^  ExplainEquation(EqClass source, EqClass target) :$/;"	f	struct:ExplainEquation
ExplainEquation	include/UnionFindExplain.h	/^struct ExplainEquation {$/;"	s
ExplainEquations	include/UnionFindExplain.h	/^typedef std::list<ExplainEquation> ExplainEquations;$/;"	t
FALSELITERAL	include/Hornsat.h	3;"	d
FLAGS	Makefile	/^FLAGS = -I$(SDIR) -I$(IDIR) -std=c++11 -Wall$/;"	m
FRESH_PREFIX	src/FactoryCurryNodes.cpp	2;"	d	file:
FSymPositions	include/EUFInterpolant.h	/^typedef std::map<std::string, std::vector<unsigned> > FSymPositions;$/;"	t
FactoryCurryNodes	include/FactoryCurryNodes.h	/^class FactoryCurryNodes {$/;"	c
FactoryCurryNodes	src/FactoryCurryNodes.cpp	/^FactoryCurryNodes::FactoryCurryNodes(const unsigned & num_terms, const CurryDeclarations & curry_decl) :$/;"	f	class:FactoryCurryNodes
HornClause	include/HornClause.h	/^class HornClause {$/;"	c
HornClause	src/HornClause.cpp	/^HornClause::HornClause(UnionFind & uf, z3::context & ctx, Z3Subterms & subterms,$/;"	f	class:HornClause
HornClauses	include/HornClauses.h	/^class HornClauses {$/;"	c
HornClauses	src/HornClauses.cpp	/^HornClauses::HornClauses(z3::context & ctx, Z3Subterms & subterms) :$/;"	f	class:HornClauses
Hornsat	include/Hornsat.h	/^class Hornsat {$/;"	c
Hornsat	src/Hornsat.cpp	/^Hornsat::Hornsat(const HornClauses & hcs, UnionFind & uf) :$/;"	f	class:Hornsat
IDIR	Makefile	/^IDIR = .\/include$/;"	m
IdsToMerge	include/CurryNode.h	/^typedef std::list<EquationZ3Ids>  IdsToMerge;$/;"	t
KindEquation	include/CurryNode.h	/^enum KindEquation { CONST_EQ, APPLY_EQ  };$/;"	g
LHS	include/CurryNode.h	/^enum SideOfEquation { LHS, RHS } ;$/;"	e	enum:SideOfEquation
Literal	include/Hornsat.h	/^  Literal() : Literal(curr_num_literals++, false, nullptr) {}$/;"	f	struct:Literal
Literal	include/Hornsat.h	/^  Literal(unsigned literal_id, bool val, struct Clause * clause_list) :$/;"	f	struct:Literal
Literal	include/Hornsat.h	/^struct Literal {$/;"	s
LookupTable	include/CongruenceClosureExplain.h	/^  LookupTable() {}$/;"	f	class:LookupTable
LookupTable	include/CongruenceClosureExplain.h	/^class LookupTable {$/;"	c
Match	include/Match.h	/^class Match {$/;"	c
Match	src/Match.cpp	/^Match::Match() {}$/;"	f	class:Match
Match	src/Match.cpp	/^Match::Match(std::vector<std::vector<unsigned> > m_vec) : m_vec(m_vec) {}$/;"	f	class:Match
OBJS	Makefile	/^OBJS = $(patsubst $(SDIR)\/%.cpp, $(ODIR)\/%.o, $(SRC)) $(Z3DIR)\/build\/libz3.$(Z3EXT) $/;"	m
ODIR	Makefile	/^ODIR = .\/obj$/;"	m
OS_FULL	src/CurryNode.cpp	2;"	d	file:
PairEquationCurryNodes	include/CurryNode.h	/^  PairEquationCurryNodes(const EquationCurryNodes & first, const EquationCurryNodes & second) :$/;"	f	struct:PairEquationCurryNodes
PairEquationCurryNodes	include/CurryNode.h	/^struct PairEquationCurryNodes {$/;"	s
PendingElement	include/CurryNode.h	/^  PendingElement(CurryNode & lhs, CurryNode & rhs) : $/;"	f	struct:PendingElement
PendingElement	include/CurryNode.h	/^  PendingElement(const EquationCurryNodes eq_cn) :$/;"	f	struct:PendingElement
PendingElement	include/CurryNode.h	/^  PendingElement(const PairEquationCurryNodes p_eq_cn) :$/;"	f	struct:PendingElement
PendingElement	include/CurryNode.h	/^struct PendingElement {$/;"	s
PendingElements	include/CurryNode.h	/^typedef std::list<PendingElement> PendingElements;$/;"	t
PendingPointers	include/CurryNode.h	/^typedef std::list<const PendingElement *> PendingPointers;$/;"	t
PendingTag	include/CurryNode.h	/^enum PendingTag { EQ, EQ_EQ };$/;"	g
PredList	include/UnionFind.h	/^typedef std::vector<std::list<EqClass> > PredList;$/;"	t
PredNode	include/CurryNode.h	/^  PredNode(CurryNode & pred, const SideOfEquation side_of_equation) :$/;"	f	struct:PredNode
PredNode	include/CurryNode.h	/^struct PredNode {$/;"	s
RHS	include/CurryNode.h	/^enum SideOfEquation { LHS, RHS } ;$/;"	e	enum:SideOfEquation
Replacement	include/Replacement.h	/^  Replacement(unsigned clause1, unsigned clause2) :$/;"	f	struct:Replacement
Replacement	include/Replacement.h	/^struct Replacement {$/;"	s
SDIR	Makefile	/^SDIR = .\/src$/;"	m
SRC	Makefile	/^SRC = $(wildcard $(SDIR)\/*.cpp)$/;"	m
SetOfUnsignedPairs	include/HornClauses.h	/^typedef std::set<std::pair<unsigned, unsigned> > SetOfUnsignedPairs;$/;"	t
SideOfEquation	include/CurryNode.h	/^enum SideOfEquation { LHS, RHS } ;$/;"	g
SignatureTable	include/CongruenceClosure.h	/^  SignatureTable(UnionFind & uf) : uf(uf){}$/;"	f	class:SignatureTable
SignatureTable	include/CongruenceClosure.h	/^class SignatureTable {$/;"	c
TestCongruenceClosureExplain	tests/TestCongruenceClosureExplain.cpp	/^TestCongruenceClosureExplain::TestCongruenceClosureExplain(z3::expr const & input_formula) :$/;"	f	class:TestCongruenceClosureExplain
TestCongruenceClosureExplain	tests/TestCongruenceClosureExplain.h	/^class TestCongruenceClosureExplain {$/;"	c
UNAME	Makefile	/^UNAME = $(shell uname)$/;"	m
UNIONFINDEXPLAIN_H	include/UnionFindExplain.h	2;"	d
UNIONFIND_H	include/UnionFind.h	2;"	d
UnionFind	include/UnionFind.h	/^class UnionFind {$/;"	c
UnionFind	src/UnionFind.cpp	/^UnionFind::UnionFind() : size(0){$/;"	f	class:UnionFind
UnionFind	src/UnionFind.cpp	/^UnionFind::UnionFind(EqClass array[], unsigned size) :$/;"	f	class:UnionFind
UnionFind	src/UnionFind.cpp	/^UnionFind::UnionFind(const UnionFind & other) :$/;"	f	class:UnionFind
UnionFind	src/UnionFind.cpp	/^UnionFind::UnionFind(unsigned size) : representative(size, 0), rank(size, 1), size(size){$/;"	f	class:UnionFind
UnionFindExplain	include/UnionFindExplain.h	/^class UnionFindExplain :  public UnionFind {$/;"	c
UnionFindExplain	src/UnionFindExplain.cpp	/^UnionFindExplain::UnionFindExplain() :$/;"	f	class:UnionFindExplain
UnionFindExplain	src/UnionFindExplain.cpp	/^UnionFindExplain::UnionFindExplain(const UnionFindExplain & other) :$/;"	f	class:UnionFindExplain
UnionFindExplain	src/UnionFindExplain.cpp	/^UnionFindExplain::UnionFindExplain(unsigned size) :$/;"	f	class:UnionFindExplain
UseList	include/CongruenceClosureExplain.h	/^typedef std::vector<std::list<const EquationCurryNodes *> > UseList;$/;"	t
VectorCurryNode	include/CurryNode.h	/^typedef std::vector<CurryNode*> VectorCurryNode;$/;"	t
WHO	Makefile	/^WHO = $(shell whoami)$/;"	m
Z3DIR	Makefile	/^	Z3DIR = \/home\/jose\/Documents\/GithubProjects\/z3__$/;"	m
Z3DIR	Makefile	/^	Z3DIR = \/nfs\/student\/j\/jose.castellanosjoo\/Documents\/GitProjects\/z3__$/;"	m
Z3DIR	Makefile	/^Z3DIR = \/Users\/joseabelcastellanosjoo\/Documents\/Applications\/z3__$/;"	m
Z3EXT	Makefile	/^Z3EXT = dylib$/;"	m
Z3EXT	Makefile	/^Z3EXT = so$/;"	m
Z3EquationPointers	include/CurryNode.h	/^typedef std::list<EquationZ3Ids> Z3EquationPointers;$/;"	t
Z3Subterms	include/Z3Subterms.h	/^struct Z3Subterms {$/;"	s
Z3Subterms	src/Z3Subterms.cpp	/^Z3Subterms::Z3Subterms(z3::context & ctx): $/;"	f	class:Z3Subterms
_CONG_CLOSUREDST__	include/CongruenceClosureDST.h	2;"	d
_CONG_CLOSURENO__	include/CongruenceClosureNO.h	2;"	d
_CONG_CLOSURE_E__	include/CongruenceClosureExplain.h	2;"	d
_CONG_CLOSURE__	include/CongruenceClosure.h	2;"	d
_CURRY_NODE_	include/CurryNode.h	2;"	d
_EUF_INTERPOLANT_	include/EUFInterpolant.h	2;"	d
_FAC_CURRY_NODES_	include/FactoryCurryNodes.h	2;"	d
_HORNSAT_	include/Hornsat.h	2;"	d
_HORN_CLAUSES_	include/HornClauses.h	2;"	d
_HORN_CLAUSE_	include/HornClause.h	2;"	d
_MATCH_	include/Match.h	2;"	d
_RENAME_	include/Rename.h	2;"	d
_REPLACEMENT_	include/Replacement.h	2;"	d
_TEST_CONG_CLOSURE_EXPLAIN_	tests/TestCongruenceClosureExplain.h	2;"	d
_Z3_SUBTERMS_	include/Z3Subterms.h	2;"	d
add	include/Hornsat.h	/^  struct Clause * add(unsigned element){$/;"	f	struct:Clause
add	src/HornClauses.cpp	/^void HornClauses::add(HornClause * hc){$/;"	f	class:HornClauses
addExtraNodes	src/FactoryCurryNodes.cpp	/^unsigned FactoryCurryNodes::addExtraNodes(unsigned num){$/;"	f	class:FactoryCurryNodes
antecedent	include/HornClause.h	/^  z3::expr_vector   antecedent;$/;"	m	class:HornClause
areCongruent	src/CongruenceClosureNO.cpp	/^bool CongruenceClosureNO::areCongruent(unsigned x, unsigned y){$/;"	f	class:CongruenceClosureNO
begin	include/Hornsat.h	/^  iterator begin(){$/;"	f	struct:Clause
begin	include/UnionFind.h	/^  iterator begin(EqClass m_element){$/;"	f	class:UnionFind
begin	src/Match.cpp	/^Match::iterator Match::begin() const { return iterator((Match*)this, 0); }$/;"	f	class:Match
begin	src/Z3Subterms.cpp	/^Z3Subterms::iterator Z3Subterms::begin() const { $/;"	f	class:Z3Subterms
buildCongruenceClosure	src/CongruenceClosureDST.cpp	/^void CongruenceClosureDST::buildCongruenceClosure(std::list<unsigned> & pending){$/;"	f	class:CongruenceClosureDST
buildCongruenceClosure	src/CongruenceClosureExplain.cpp	/^void CongruenceClosureExplain::buildCongruenceClosure(std::list<EqClass> & pending){$/;"	f	class:CongruenceClosureExplain
buildCongruenceClosure	src/CongruenceClosureNO.cpp	/^void CongruenceClosureNO::buildCongruenceClosure(std::list<unsigned> & pending){$/;"	f	class:CongruenceClosureNO
buildHCBody	src/EUFInterpolant.cpp	/^z3::expr_vector EUFInterpolant::buildHCBody(z3::expr const & t1, z3::expr const & t2){$/;"	f	class:EUFInterpolant
buildInterpolant	src/EUFInterpolant.cpp	/^z3::expr EUFInterpolant::buildInterpolant(std::vector<Replacement> replacements){$/;"	f	class:EUFInterpolant
cc	include/EUFInterpolant.h	/^  CongruenceClosureExplain cc;$/;"	m	class:EUFInterpolant
cc	tests/TestCongruenceClosureExplain.h	/^  CongruenceClosureExplain cc;$/;"	m	class:TestCongruenceClosureExplain
checkTriviality	src/HornClause.cpp	/^bool HornClause::checkTriviality(){$/;"	f	class:HornClause
class_list	include/Hornsat.h	/^  ClassList            class_list;$/;"	m	class:Hornsat
clause1	include/Replacement.h	/^  unsigned clause1, clause2;$/;"	m	struct:Replacement
clause2	include/Replacement.h	/^  unsigned clause1, clause2;$/;"	m	struct:Replacement
clause_id	include/Hornsat.h	/^  unsigned clause_id;$/;"	m	struct:Clause
clause_list	include/Hornsat.h	/^  struct Clause * clause_list;$/;"	m	struct:Literal	typeref:struct:Literal::Clause
combine	src/CongruenceClosureNO.cpp	/^void CongruenceClosureNO::combine(unsigned u, unsigned v){$/;"	f	class:CongruenceClosureNO
combine	src/UnionFind.cpp	/^void UnionFind::combine(EqClass x, EqClass y){$/;"	f	class:UnionFind
combine	src/UnionFindExplain.cpp	/^void UnionFindExplain::combine(EqClass target, EqClass source, const PendingElement * pe){$/;"	f	class:UnionFindExplain
commonAncestor	src/UnionFindExplain.cpp	/^EqClass UnionFindExplain::commonAncestor(EqClass x, EqClass y) {$/;"	f	class:UnionFindExplain
commonAncestorHelper	src/UnionFindExplain.cpp	/^EqClass UnionFindExplain::commonAncestorHelper(EqClass aux_x, EqClass aux_y, unsigned depth_diff){$/;"	f	class:UnionFindExplain
compareEquation	src/HornClause.cpp	/^bool HornClause::compareEquation(const z3::expr & eq1, const z3::expr & eq2){$/;"	f	class:HornClause
compareTerm	src/HornClause.cpp	/^bool HornClause::compareTerm(const z3::expr & t1, const z3::expr & t2){$/;"	f	class:HornClause
conditionalElimination	src/HornClauses.cpp	/^void HornClauses::conditionalElimination(std::vector<Replacement> replacements){$/;"	f	class:HornClauses
conditionalReplacement	src/EUFInterpolant.cpp	/^z3::expr_vector EUFInterpolant::conditionalReplacement(z3::expr_vector & terms_to_replace){ \/\/ TODO:$/;"	f	class:EUFInterpolant
congclosure	src/Hornsat.cpp	/^void Hornsat::congclosure(CongruenceClosure & cc, std::list<unsigned> & pending){$/;"	f	class:Hornsat
consequent	include/HornClause.h	/^  z3::expr          consequent;$/;"	m	class:HornClause
consistent	include/Hornsat.h	/^  bool                 consistent;$/;"	m	class:Hornsat
const_id	include/CurryNode.h	/^  unsigned id, z3_id, const_id;$/;"	m	class:CurryNode
constantCurryNode	src/FactoryCurryNodes.cpp	/^CurryNode * FactoryCurryNodes::constantCurryNode(unsigned index){$/;"	f	class:FactoryCurryNodes
constantZ3Index	src/FactoryCurryNodes.cpp	/^CurryNode * FactoryCurryNodes::constantZ3Index(unsigned id){$/;"	f	class:FactoryCurryNodes
contradiction	include/EUFInterpolant.h	/^  z3::expr        contradiction;$/;"	m	class:EUFInterpolant
contradiction	tests/TestCongruenceClosureExplain.h	/^  z3::expr        contradiction;$/;"	m	class:TestCongruenceClosureExplain
ctx	include/EUFInterpolant.h	/^  z3::context &   ctx;$/;"	m	class:EUFInterpolant
ctx	include/HornClause.h	/^  z3::context &     ctx;$/;"	m	class:HornClause
ctx	include/HornClauses.h	/^  z3::context &             ctx;$/;"	m	class:HornClauses
ctx	tests/TestCongruenceClosureExplain.h	/^  z3::context &   ctx;$/;"	m	class:TestCongruenceClosureExplain
curr_num_horn_clauses	include/HornClauses.h	/^  unsigned                  curr_num_horn_clauses = 0;$/;"	m	class:HornClauses
curr_num_literals	include/Hornsat.h	/^  static unsigned curr_num_literals;$/;"	m	struct:Literal
curr_num_literals	src/Hornsat.cpp	/^unsigned Literal::curr_num_literals = 0;$/;"	m	class:Literal	file:
currentProgress	tests/current_progress.cpp	/^void currentProgress(){$/;"	f
curry_decl	include/EUFInterpolant.h	/^  CurryDeclarations        curry_decl;  $/;"	m	class:EUFInterpolant
curry_decl	include/FactoryCurryNodes.h	/^  const CurryDeclarations & curry_decl;$/;"	m	class:FactoryCurryNodes
curry_decl	tests/TestCongruenceClosureExplain.h	/^  CurryDeclarations curry_decl;  $/;"	m	class:TestCongruenceClosureExplain
curry_hasher	include/FactoryCurryNodes.h	/^  std::hash<CurryNode*>                       curry_hasher;$/;"	m	class:FactoryCurryNodes
curry_nodes	include/FactoryCurryNodes.h	/^  VectorCurryNode           curry_nodes;$/;"	m	class:FactoryCurryNodes
curry_predecessors	include/FactoryCurryNodes.h	/^  CurryPreds                curry_predecessors;$/;"	m	class:FactoryCurryNodes
curryfication	src/FactoryCurryNodes.cpp	/^IdsToMerge FactoryCurryNodes::curryfication(z3::expr const & e){$/;"	f	class:FactoryCurryNodes
curryficationHelper	src/FactoryCurryNodes.cpp	/^void FactoryCurryNodes::curryficationHelper(z3::expr const & e, std::vector<bool> & visited, IdsToMerge & ids_to_merge){$/;"	f	class:FactoryCurryNodes
depth	src/UnionFindExplain.cpp	/^unsigned UnionFindExplain::depth(EqClass x){$/;"	f	class:UnionFindExplain
disequalities	include/EUFInterpolant.h	/^  z3::expr_vector disequalities;$/;"	m	class:EUFInterpolant
disequalitiesToHCS	src/EUFInterpolant.cpp	/^void EUFInterpolant::disequalitiesToHCS(){$/;"	f	class:EUFInterpolant
end	include/Hornsat.h	/^  iterator end(){$/;"	f	struct:Clause
end	include/UnionFind.h	/^  iterator end(EqClass m_element){ return iterator(this, m_element, size); }$/;"	f	class:UnionFind
end	src/Match.cpp	/^Match::iterator Match::end() const { return iterator((Match*)this, m_vec.size()); }$/;"	f	class:Match
end	src/Z3Subterms.cpp	/^Z3Subterms::iterator Z3Subterms::end() const { $/;"	f	class:Z3Subterms
enter	include/CongruenceClosure.h	/^  void enter(const z3::expr & e){$/;"	f	class:SignatureTable
enter	include/CongruenceClosureExplain.h	/^  void enter(EqClass a1, EqClass a2, const EquationCurryNodes * ecn){$/;"	f	class:LookupTable
eq_cn	include/CurryNode.h	/^    const EquationCurryNodes eq_cn;$/;"	m	union:PendingElement::__anon1
eq_side	include/Hornsat.h	/^  SideOfEquation eq_side;$/;"	m	struct:ClassListPos
equations_to_merge	include/CongruenceClosureExplain.h	/^  PendingPointers equations_to_merge;$/;"	m	class:CongruenceClosureExplain
erase	include/CongruenceClosure.h	/^  void erase(const z3::expr & e){$/;"	f	class:SignatureTable
erase	include/CongruenceClosureExplain.h	/^  void erase(EqClass a1, EqClass a2){$/;"	f	class:LookupTable
explain	src/CongruenceClosureExplain.cpp	/^PendingPointers CongruenceClosureExplain::explain(EqClass x, EqClass y){$/;"	f	class:CongruenceClosureExplain
explain	src/CongruenceClosureExplain.cpp	/^PendingPointers CongruenceClosureExplain::explain(const z3::expr & lhs, const z3::expr & rhs){$/;"	f	class:CongruenceClosureExplain
explain	src/UnionFindExplain.cpp	/^ExplainEquations UnionFindExplain::explain(EqClass x, EqClass y){$/;"	f	class:UnionFindExplain
explainAlongPath	src/CongruenceClosureExplain.cpp	/^void CongruenceClosureExplain::explainAlongPath(EqClass a, EqClass c, $/;"	f	class:CongruenceClosureExplain
explainAlongPath	src/UnionFindExplain.cpp	/^void UnionFindExplain::explainAlongPath(EqClass node, EqClass representative, ExplainEquations & explanations) {$/;"	f	class:UnionFindExplain
exposeUncommons	src/EUFInterpolant.cpp	/^void EUFInterpolant::exposeUncommons(){$/;"	f	class:EUFInterpolant
factory_curry_nodes	include/CongruenceClosureExplain.h	/^  FactoryCurryNodes & factory_curry_nodes;$/;"	m	class:CongruenceClosureExplain
factory_curry_nodes	include/EUFInterpolant.h	/^  FactoryCurryNodes        factory_curry_nodes;$/;"	m	class:EUFInterpolant
factory_curry_nodes	tests/TestCongruenceClosureExplain.h	/^  FactoryCurryNodes factory_curry_nodes;$/;"	m	class:TestCongruenceClosureExplain
facts	include/Hornsat.h	/^  std::queue<unsigned> facts;$/;"	m	class:Hornsat
find	src/UnionFind.cpp	/^EqClass UnionFind::find(EqClass x){$/;"	f	class:UnionFind
first	include/CurryNode.h	/^  const EquationCurryNodes & first, & second;$/;"	m	struct:PairEquationCurryNodes
flattening	src/FactoryCurryNodes.cpp	/^void FactoryCurryNodes::flattening(PendingElements & pending_elements,$/;"	f	class:FactoryCurryNodes
fsym_positions	include/EUFInterpolant.h	/^  FSymPositions    fsym_positions;$/;"	m	class:EUFInterpolant
fsym_positions	tests/TestCongruenceClosureExplain.h	/^  FSymPositions    fsym_positions;$/;"	m	class:TestCongruenceClosureExplain
func_name	include/CurryNode.h	/^  std::string func_name;$/;"	m	class:CurryNode
getAntecedent	src/HornClause.cpp	/^const z3::expr_vector & HornClause::getAntecedent() const {$/;"	f	class:HornClause
getConsequent	src/HornClause.cpp	/^const z3::expr & HornClause::getConsequent() const {$/;"	f	class:HornClause
getConstId	src/CurryNode.cpp	/^const unsigned CurryNode::getConstId() const {$/;"	f	class:CurryNode
getCurryNode	src/FactoryCurryNodes.cpp	/^CurryNode * FactoryCurryNodes::getCurryNode(std::size_t index) const {$/;"	f	class:FactoryCurryNodes
getCurryNodeById	src/FactoryCurryNodes.cpp	/^CurryNode * FactoryCurryNodes::getCurryNodeById(unsigned i) const {$/;"	f	class:FactoryCurryNodes
getHornClauses	src/HornClauses.cpp	/^const std::vector<HornClause*> & HornClauses::getHornClauses() const {$/;"	f	class:HornClauses
getId	src/CurryNode.cpp	/^const unsigned CurryNode::getId() const {$/;"	f	class:CurryNode
getIndex	include/Z3Subterms.h	/^    unsigned getIndex() const {$/;"	f	class:Z3Subterms::iterator
getLabel	src/UnionFindExplain.cpp	/^const PendingElement * UnionFindExplain::getLabel(EqClass x){$/;"	f	class:UnionFindExplain
getLeftId	src/CurryNode.cpp	/^const unsigned CurryNode::getLeftId() const {$/;"	f	class:CurryNode
getRank	include/UnionFind.h	/^  const unsigned getRank(EqClass i) { return rank[find(i)]; }$/;"	f	class:UnionFind
getRightId	src/CurryNode.cpp	/^const unsigned CurryNode::getRightId() const {$/;"	f	class:CurryNode
getSize	include/UnionFind.h	/^  const unsigned getSize() const { return size; }$/;"	f	class:UnionFind
getSubterms	src/HornClauses.cpp	/^const Z3Subterms & HornClauses::getSubterms() const {$/;"	f	class:HornClauses
getZ3Id	src/CurryNode.cpp	/^const unsigned CurryNode::getZ3Id() const {$/;"	f	class:CurryNode
giveExplanation	src/CongruenceClosureExplain.cpp	/^std::ostream & CongruenceClosureExplain::giveExplanation(std::ostream & os, EqClass lhs, EqClass rhs){$/;"	f	class:CongruenceClosureExplain
giveExplanation	src/CongruenceClosureExplain.cpp	/^std::ostream & CongruenceClosureExplain::giveExplanation(std::ostream & os, const z3::expr & lhs, const z3::expr & rhs){$/;"	f	class:CongruenceClosureExplain
giveExplanation	src/UnionFindExplain.cpp	/^std::ostream & UnionFindExplain::giveExplanation(std::ostream & os, EqClass x, EqClass y){$/;"	f	class:UnionFindExplain
giveZ3Explanation	src/CongruenceClosureExplain.cpp	/^std::ostream & CongruenceClosureExplain::giveZ3Explanation(std::ostream & os, const z3::expr & lhs, const z3::expr & rhs){$/;"	f	class:CongruenceClosureExplain
greater	src/UnionFind.cpp	/^bool UnionFind::greater(EqClass x, EqClass y){$/;"	f	class:UnionFind
hash	src/CurryNode.cpp	/^std::size_t CurryNode::hash(){$/;"	f	class:CurryNode
hash_combine	include/CongruenceClosureExplain.h	/^  std::size_t hash_combine(EqClass a1, EqClass a2){$/;"	f	class:LookupTable
hash_combine	include/CurryNode.h	/^inline void hash_combine(std::size_t & seed, const T & v, const std::hash<T> & hasher){$/;"	f
hash_string	include/CongruenceClosure.h	/^  std::hash<std::string> hash_string;$/;"	m	class:SignatureTable
hash_table	include/FactoryCurryNodes.h	/^  std::unordered_map<std::size_t, CurryNode*> hash_table;$/;"	m	class:FactoryCurryNodes
hash_unsigned	include/CongruenceClosure.h	/^  std::hash<unsigned> hash_unsigned;$/;"	m	class:SignatureTable
hash_z3expr	include/CongruenceClosure.h	/^  std::size_t hash_z3expr(const z3::expr & e){$/;"	f	class:SignatureTable
highestNode	src/CongruenceClosureExplain.cpp	/^EqClass CongruenceClosureExplain::highestNode(EqClass a, UnionFind & uf){$/;"	f	class:CongruenceClosureExplain
horn_clauses	include/EUFInterpolant.h	/^  HornClauses      horn_clauses;$/;"	m	class:EUFInterpolant
horn_clauses	include/HornClauses.h	/^  std::vector<HornClause *> horn_clauses;$/;"	m	class:HornClauses
id	include/CurryNode.h	/^  unsigned id, z3_id, const_id;$/;"	m	class:CurryNode
init	src/EUFInterpolant.cpp	/^void EUFInterpolant::init(z3::expr const & e){$/;"	f	class:EUFInterpolant
init	tests/TestCongruenceClosureExplain.cpp	/^void TestCongruenceClosureExplain::init(z3::expr const & e){$/;"	f	class:TestCongruenceClosureExplain
initPredList	src/EUFInterpolant.cpp	/^void EUFInterpolant::initPredList(z3::expr const & e){$/;"	f	class:EUFInterpolant
insert	include/EUFInterpolant.h	/^void insert(std::list<T> & l, T element){$/;"	f
isCommon	src/CurryNode.cpp	/^const bool CurryNode::isCommon() const {$/;"	f	class:CurryNode
isCommonAntecedent	src/HornClause.cpp	/^bool HornClause::isCommonAntecedent(){$/;"	f	class:HornClause
isCommonConsequent	src/HornClause.cpp	/^bool HornClause::isCommonConsequent(){$/;"	f	class:HornClause
isConsistent	src/Hornsat.cpp	/^bool Hornsat::isConsistent(){$/;"	f	class:Hornsat
isConstant	src/CurryNode.cpp	/^const bool CurryNode::isConstant() const {$/;"	f	class:CurryNode
isDefined	src/CurryNode.cpp	/^const bool CurryNode::isDefined() const {$/;"	f	class:CurryNode
isReplaceable	src/CurryNode.cpp	/^const bool CurryNode::isReplaceable() const {$/;"	f	class:CurryNode
isValid	include/Z3Subterms.h	/^    bool isValid() const {$/;"	f	class:Z3Subterms::iterator
is_common	include/CurryNode.h	/^  bool is_common = false;$/;"	m	class:CurryNode
is_common_antecedent	include/HornClause.h	/^  bool              is_common_antecedent = true;$/;"	m	class:HornClause
it	include/Hornsat.h	/^    struct Clause * it;$/;"	m	class:Clause::iterator	typeref:struct:Clause::iterator::Clause
iterator	include/Hornsat.h	/^    iterator(struct Clause * n) : it(n){}$/;"	f	class:Clause::iterator
iterator	include/Hornsat.h	/^  class iterator {$/;"	c	struct:Clause
iterator	include/Match.h	/^  class iterator {$/;"	c	class:Match
iterator	include/UnionFind.h	/^    iterator(UnionFind * m_uf, EqClass m_element, unsigned m_index) :$/;"	f	class:UnionFind::iterator
iterator	include/UnionFind.h	/^  class iterator {$/;"	c	class:UnionFind
iterator	include/Z3Subterms.h	/^    iterator(const Z3Subterms * s, unsigned i): m_subterms(s), m_index(i) {}$/;"	f	class:Z3Subterms::iterator
iterator	include/Z3Subterms.h	/^  class iterator {$/;"	c	struct:Z3Subterms
iterator	src/Match.cpp	/^Match::iterator::iterator(Match * m_vec, unsigned i) : m_vec(m_vec), m_index(i) {}$/;"	f	class:Match::iterator
kind_equation	include/CurryNode.h	/^  KindEquation kind_equation;$/;"	m	struct:EquationCurryNodes
l_class	include/Hornsat.h	/^  unsigned l_class, r_class;$/;"	m	struct:Literal
l_id	include/Hornsat.h	/^  unsigned l_id, r_id;$/;"	m	struct:Literal
labels	include/UnionFindExplain.h	/^  std::vector<const PendingElement *> labels;$/;"	m	class:UnionFindExplain
left	include/CurryNode.h	/^  CurryNode * left, * right;$/;"	m	class:CurryNode
lhs	include/CurryNode.h	/^  const CurryNode & lhs, & rhs;$/;"	m	struct:EquationCurryNodes
lhs_id	include/CurryNode.h	/^  unsigned lhs_id, rhs_id;$/;"	m	struct:EquationZ3Ids
link	src/UnionFind.cpp	/^void UnionFind::link(EqClass x, EqClass y){$/;"	f	class:UnionFind
list_of_literals	include/Hornsat.h	/^  std::vector<Literal> list_of_literals;$/;"	m	class:Hornsat
lit_pointer	include/Hornsat.h	/^  Literal * lit_pointer;$/;"	m	struct:ClassListPos
literal_id	include/Hornsat.h	/^  unsigned literal_id;$/;"	m	struct:Literal
lookup_table	include/CongruenceClosureExplain.h	/^  LookupTable lookup_table;$/;"	m	class:CongruenceClosureExplain
m_element	include/UnionFind.h	/^    EqClass    m_element;$/;"	m	class:UnionFind::iterator
m_index	include/Match.h	/^    unsigned m_index;$/;"	m	class:Match::iterator
m_index	include/UnionFind.h	/^    unsigned    m_index;$/;"	m	class:UnionFind::iterator
m_index	include/Z3Subterms.h	/^    unsigned m_index;$/;"	m	class:Z3Subterms::iterator
m_subterms	include/Z3Subterms.h	/^    const Z3Subterms * m_subterms;$/;"	m	class:Z3Subterms::iterator
m_uf	include/UnionFind.h	/^    UnionFind * m_uf;$/;"	m	class:UnionFind::iterator
m_vec	include/Match.h	/^    Match * m_vec;$/;"	m	class:Match::iterator
m_vec	include/Match.h	/^  std::vector<std::vector<unsigned> > m_vec;$/;"	m	class:Match
main	tests/cong_closure_expl_test.cpp	/^int main(int argc, char ** argv){$/;"	f
main	tests/current_progress.cpp	/^int main(int argc, char ** argv){$/;"	f
main	tests/qf_uf_test.cpp	/^int main(int argc, char ** argv){$/;"	f
matched	include/HornClause.h	/^  std::vector<bool> matched;$/;"	m	class:HornClause
merge	src/CongruenceClosureExplain.cpp	/^void CongruenceClosureExplain::merge(){$/;"	f	class:CongruenceClosureExplain
merge	src/CongruenceClosureExplain.cpp	/^void CongruenceClosureExplain::merge(const EquationCurryNodes & equation){$/;"	f	class:CongruenceClosureExplain
merge	src/UnionFind.cpp	/^void UnionFind::merge(EqClass x, EqClass y){$/;"	f	class:UnionFind
merge	src/UnionFindExplain.cpp	/^void UnionFindExplain::merge(EqClass target, EqClass source, const PendingElement * pe){$/;"	f	class:UnionFindExplain
nearestCommonAncestor	src/CongruenceClosureExplain.cpp	/^EqClass CongruenceClosureExplain::nearestCommonAncestor(EqClass a, EqClass b, UnionFind & uf){$/;"	f	class:CongruenceClosureExplain
newCurryNode	src/FactoryCurryNodes.cpp	/^CurryNode * FactoryCurryNodes::newCurryNode(unsigned id, std::string func_name,$/;"	f	class:FactoryCurryNodes
next	include/Hornsat.h	/^  struct Clause * next;$/;"	m	struct:Clause	typeref:struct:Clause::Clause
normalize	src/HornClause.cpp	/^void HornClause::normalize(){$/;"	f	class:HornClause
notInSet	include/HornClauses.h	3;"	d
numUncommAntecedent	src/HornClause.cpp	/^unsigned HornClause::numUncommAntecedent(){$/;"	f	class:HornClause
num_args	include/Hornsat.h	/^  std::vector<unsigned> num_args, pos_lit_list;$/;"	m	class:Hornsat
num_hcs	include/Hornsat.h	/^  unsigned             num_pos, num_hcs, num_literals;$/;"	m	class:Hornsat
num_literals	include/Hornsat.h	/^  unsigned             num_pos, num_hcs, num_literals;$/;"	m	class:Hornsat
num_pos	include/Hornsat.h	/^  unsigned             num_pos, num_hcs, num_literals;$/;"	m	class:Hornsat
num_terms	include/CongruenceClosureExplain.h	/^  unsigned            num_terms;$/;"	m	class:CongruenceClosureExplain
num_terms	include/FactoryCurryNodes.h	/^  const unsigned & num_terms;$/;"	m	class:FactoryCurryNodes
num_uncomm_antecedent	include/HornClause.h	/^  unsigned          num_uncomm_antecedent = 0;$/;"	m	class:HornClause
operator !=	include/Hornsat.h	/^    bool operator !=(iterator const & other){$/;"	f	class:Clause::iterator
operator !=	include/UnionFind.h	/^    bool operator !=(iterator const & other) { return m_element != other.m_element || m_index != other.m_index; }$/;"	f	class:UnionFind::iterator
operator !=	include/Z3Subterms.h	/^    bool operator!=(const iterator & other) const { $/;"	f	class:Z3Subterms::iterator
operator !=	src/Match.cpp	/^bool Match::iterator::operator !=(iterator const & other) const {$/;"	f	class:Match::iterator
operator *	include/Hornsat.h	/^    struct Clause * operator *(){$/;"	f	class:Clause::iterator
operator *	include/UnionFind.h	/^    EqClass operator *(){ return m_index; }$/;"	f	class:UnionFind::iterator
operator *	include/Z3Subterms.h	/^    z3::expr operator*() const {$/;"	f	class:Z3Subterms::iterator
operator *	src/Match.cpp	/^std::vector<unsigned> Match::iterator::operator *() const {$/;"	f	class:Match::iterator
operator ++	include/Hornsat.h	/^    iterator & operator ++(){$/;"	f	class:Clause::iterator
operator ++	include/UnionFind.h	/^    iterator & operator ++(){$/;"	f	class:UnionFind::iterator
operator ++	include/Z3Subterms.h	/^    iterator & operator++() {$/;"	f	class:Z3Subterms::iterator
operator ++	src/Match.cpp	/^Match::iterator & Match::iterator::operator ++(){$/;"	f	class:Match::iterator
operator <	src/HornClause.cpp	/^bool operator < (const HornClause & hc1, const HornClause & hc2){$/;"	f
operator <<	include/CongruenceClosure.h	/^  friend std::ostream & operator << (std::ostream & os, const SignatureTable & st){$/;"	f	class:SignatureTable
operator <<	include/CongruenceClosureExplain.h	/^  friend std::ostream & operator << (std::ostream & os, const LookupTable & lt){$/;"	f	class:LookupTable
operator <<	include/CurryNode.h	/^  friend std::ostream & operator << (std::ostream & os, const EquationCurryNodes & ecns){$/;"	f	struct:EquationCurryNodes
operator <<	include/CurryNode.h	/^  friend std::ostream & operator << (std::ostream & os, const EquationZ3Ids & ez3ids){$/;"	f	struct:EquationZ3Ids
operator <<	include/CurryNode.h	/^  friend std::ostream & operator << (std::ostream & os, const PairEquationCurryNodes & pecns){$/;"	f	struct:PairEquationCurryNodes
operator <<	include/CurryNode.h	/^  friend std::ostream & operator << (std::ostream & os, const PendingElement & pe){$/;"	f	struct:PendingElement
operator <<	include/CurryNode.h	/^  friend std::ostream & operator << (std::ostream & os, const PredNode & pred_pair){$/;"	f	struct:PredNode
operator <<	include/Hornsat.h	/^  friend std::ostream & operator << (std::ostream & os, const ClassListPos & clp){$/;"	f	struct:ClassListPos
operator <<	include/Hornsat.h	/^  friend std::ostream & operator << (std::ostream & os, const Literal & l){$/;"	f	struct:Literal
operator <<	include/Replacement.h	/^  friend std::ostream & operator << (std::ostream & os, const Replacement & r){$/;"	f	struct:Replacement
operator <<	include/UnionFindExplain.h	/^  friend std::ostream & operator << (std::ostream & os, const ExplainEquation & eq){$/;"	f	struct:ExplainEquation
operator <<	src/CongruenceClosure.cpp	/^std::ostream & operator << (std::ostream & os, const CongruenceClosure & cc){$/;"	f
operator <<	src/CongruenceClosureDST.cpp	/^std::ostream & operator << (std::ostream & os, const CongruenceClosureDST & cc){$/;"	f
operator <<	src/CongruenceClosureExplain.cpp	/^std::ostream & operator << (std::ostream & os, const CongruenceClosureExplain & cc){$/;"	f
operator <<	src/CongruenceClosureNO.cpp	/^std::ostream & operator << (std::ostream & os, const CongruenceClosureNO & cc){$/;"	f
operator <<	src/CurryNode.cpp	/^std::ostream & operator << (std::ostream & os, const CurryNode & cn){$/;"	f
operator <<	src/EUFInterpolant.cpp	/^std::ostream & operator << (std::ostream & os, EUFInterpolant & euf){$/;"	f
operator <<	src/FactoryCurryNodes.cpp	/^std::ostream & operator << (std::ostream & os, const FactoryCurryNodes & fcns){$/;"	f
operator <<	src/HornClause.cpp	/^std::ostream & operator << (std::ostream & os, const HornClause & hc){$/;"	f
operator <<	src/HornClauses.cpp	/^std::ostream & operator << (std::ostream & os, const HornClauses & hcs){$/;"	f
operator <<	src/Hornsat.cpp	/^std::ostream & operator << (std::ostream & os, const Hornsat & hsat){$/;"	f
operator <<	src/Match.cpp	/^std::ostream & operator << (std::ostream & os, const Match & m){$/;"	f
operator <<	src/UnionFind.cpp	/^std::ostream & operator << (std::ostream & os, UnionFind & uf){$/;"	f
operator <<	src/UnionFindExplain.cpp	/^std::ostream & operator << (std::ostream & os, UnionFindExplain & uf){$/;"	f
operator <<	tests/TestCongruenceClosureExplain.cpp	/^std::ostream & operator << (std::ostream & os, TestCongruenceClosureExplain & test) {$/;"	f
operator =	include/Z3Subterms.h	/^    iterator operator=(const iterator & other) {$/;"	f	class:Z3Subterms::iterator
operator ==	include/Hornsat.h	/^    bool operator ==(iterator const & other){$/;"	f	class:Clause::iterator
operator ==	include/UnionFind.h	/^    bool operator ==(iterator const & other) { return m_element == other.m_element && m_index == other.m_index; }$/;"	f	class:UnionFind::iterator
operator ==	include/Z3Subterms.h	/^    bool operator==(const iterator & other) const { $/;"	f	class:Z3Subterms::iterator
operator ==	src/Match.cpp	/^bool Match::iterator::operator ==(iterator const & other) const {$/;"	f	class:Match::iterator
operator ==	src/UnionFind.cpp	/^bool UnionFind::operator ==(const UnionFind & other){$/;"	f	class:UnionFind
operator >	src/HornClause.cpp	/^bool operator > (const HornClause & hc1, const HornClause & hc2){$/;"	f
operator []	src/HornClauses.cpp	/^HornClause* HornClauses::operator[](unsigned i){$/;"	f	class:HornClauses
operator []	src/Match.cpp	/^std::vector<unsigned> Match::operator [](unsigned i){$/;"	f	class:Match
operator []	src/Z3Subterms.cpp	/^z3::expr Z3Subterms::operator[](unsigned i) const {$/;"	f	class:Z3Subterms
orient	src/HornClause.cpp	/^void HornClause::orient(){$/;"	f	class:HornClause
original_num_terms	include/EUFInterpolant.h	/^  unsigned original_num_terms;$/;"	m	class:EUFInterpolant
original_num_terms	tests/TestCongruenceClosureExplain.h	/^  unsigned original_num_terms;$/;"	m	class:TestCongruenceClosureExplain
p_eq_cn	include/CurryNode.h	/^    const PairEquationCurryNodes p_eq_cn;$/;"	m	union:PendingElement::__anon1
parentProofForest	src/UnionFindExplain.cpp	/^EqClass UnionFindExplain::parentProofForest(EqClass x){$/;"	f	class:UnionFindExplain
pending_elements	include/CongruenceClosureExplain.h	/^  PendingElements pending_elements;$/;"	m	class:CongruenceClosureExplain
pending_to_propagate	include/CongruenceClosureExplain.h	/^  PendingPointers pending_to_propagate;$/;"	m	class:CongruenceClosureExplain
pos_lit_list	include/Hornsat.h	/^  std::vector<unsigned> num_args, pos_lit_list;$/;"	m	class:Hornsat
pred	include/CurryNode.h	/^  CurryNode & pred;$/;"	m	struct:PredNode
pred_list	include/CongruenceClosure.h	/^  PredList &         pred_list;$/;"	m	class:CongruenceClosure
pred_list	include/EUFInterpolant.h	/^  PredList         pred_list;$/;"	m	class:EUFInterpolant
pred_list	include/HornClause.h	/^  PredList &        pred_list;$/;"	m	class:HornClause
pred_list	tests/TestCongruenceClosureExplain.h	/^  PredList         pred_list;$/;"	m	class:TestCongruenceClosureExplain
processEqs	src/EUFInterpolant.cpp	/^void EUFInterpolant::processEqs(z3::expr const & e){$/;"	f	class:EUFInterpolant
processEqs	src/EUFInterpolant.cpp	/^void EUFInterpolant::processEqs(z3::expr const & e, CongruenceClosureNO & cc_no){$/;"	f	class:EUFInterpolant
proof_forest	include/UnionFindExplain.h	/^  std::vector<EqClass>                proof_forest;$/;"	m	class:UnionFindExplain
propagate	src/CongruenceClosureExplain.cpp	/^void CongruenceClosureExplain::propagate(){$/;"	f	class:CongruenceClosureExplain
propagateAux	src/CongruenceClosureExplain.cpp	/^void CongruenceClosureExplain::propagateAux(const CurryNode & a, const CurryNode & b,$/;"	f	class:CongruenceClosureExplain
pushPending	src/CongruenceClosureExplain.cpp	/^void CongruenceClosureExplain::pushPending(PendingPointers & pending_pointers, $/;"	f	class:CongruenceClosureExplain
push_back	src/Match.cpp	/^void Match::push_back(z3::expr const & e, unsigned i){$/;"	f	class:Match
query	include/CongruenceClosure.h	/^  unsigned query(const z3::expr & e){$/;"	f	class:SignatureTable
query	include/CongruenceClosureExplain.h	/^  const EquationCurryNodes * query(EqClass a1, EqClass a2){$/;"	f	class:LookupTable
r_class	include/Hornsat.h	/^  unsigned l_class, r_class;$/;"	m	struct:Literal
r_id	include/Hornsat.h	/^  unsigned l_id, r_id;$/;"	m	struct:Literal
rank	include/UnionFind.h	/^  std::vector<unsigned> rank;$/;"	m	class:UnionFind
reformulate	src/Rename.cpp	/^z3::expr reformulate(z3::expr const & e,$/;"	f
rename	src/Rename.cpp	/^std::pair<z3::expr, z3::expr> rename(z3::expr & a, z3::expr & b){$/;"	f
rename	src/Rename.cpp	/^z3::expr rename(z3::expr & a, const std::set<std::string> & uncommon_names){$/;"	f
repr	src/EUFInterpolant.cpp	/^z3::expr EUFInterpolant::repr(const z3::expr & t){$/;"	f	class:EUFInterpolant
representative	include/UnionFind.h	/^  std::vector<EqClass> representative;$/;"	m	class:UnionFind
resize	src/UnionFind.cpp	/^void UnionFind::resize(unsigned sz){$/;"	f	class:UnionFind
resize	src/UnionFindExplain.cpp	/^void UnionFindExplain::resize(unsigned sz){$/;"	f	class:UnionFindExplain
resize	src/Z3Subterms.cpp	/^void Z3Subterms::resize(unsigned size) { subterms.resize(size); visited.resize(size, false); }$/;"	f	class:Z3Subterms
rhs	include/CurryNode.h	/^  const CurryNode & lhs, & rhs;$/;"	m	struct:EquationCurryNodes
rhs_id	include/CurryNode.h	/^  unsigned lhs_id, rhs_id;$/;"	m	struct:EquationZ3Ids
right	include/CurryNode.h	/^  CurryNode * left, * right;$/;"	m	class:CurryNode
satisfiable	src/Hornsat.cpp	/^std::vector<Replacement> Hornsat::satisfiable(CongruenceClosure & cc){$/;"	f	class:Hornsat
second	include/CurryNode.h	/^  const EquationCurryNodes & first, & second;$/;"	m	struct:PairEquationCurryNodes
set	src/Z3Subterms.cpp	/^void Z3Subterms::set(unsigned index, const z3::expr & e) {$/;"	f	class:Z3Subterms
side_of_equation	include/CurryNode.h	/^  const SideOfEquation side_of_equation;$/;"	m	struct:PredNode
sig_table	include/CongruenceClosure.h	/^  SignatureTable     sig_table;$/;"	m	class:CongruenceClosure
sig_table	include/CongruenceClosure.h	/^  std::unordered_map<std::size_t, unsigned> sig_table;$/;"	m	class:SignatureTable
sig_table	include/CongruenceClosureExplain.h	/^  std::unordered_map<std::size_t, const EquationCurryNodes*> sig_table;$/;"	m	class:LookupTable
size	include/UnionFind.h	/^  unsigned              size;$/;"	m	class:UnionFind
size	src/FactoryCurryNodes.cpp	/^const unsigned FactoryCurryNodes::size() const {$/;"	f	class:FactoryCurryNodes
size	src/HornClauses.cpp	/^unsigned HornClauses::size() const {$/;"	f	class:HornClauses
size	src/Match.cpp	/^unsigned Match::size(){$/;"	f	class:Match
size	src/Z3Subterms.cpp	/^unsigned Z3Subterms::size() const { return subterms.size(); }$/;"	f	class:Z3Subterms
source	include/UnionFindExplain.h	/^  EqClass source, target;$/;"	m	struct:ExplainEquation
space	include/CurryNode.h	/^  unsigned space = 1;$/;"	m	class:CurryNode
string_hasher	include/FactoryCurryNodes.h	/^  std::hash<std::string>                      string_hasher;$/;"	m	class:FactoryCurryNodes
subterms	include/CongruenceClosure.h	/^  const Z3Subterms & subterms;$/;"	m	class:CongruenceClosure
subterms	include/CongruenceClosureExplain.h	/^  const Z3Subterms &  subterms;$/;"	m	class:CongruenceClosureExplain
subterms	include/EUFInterpolant.h	/^  Z3Subterms      subterms;$/;"	m	class:EUFInterpolant
subterms	include/HornClause.h	/^  Z3Subterms &      subterms;$/;"	m	class:HornClause
subterms	include/HornClauses.h	/^  Z3Subterms &              subterms;$/;"	m	class:HornClauses
subterms	include/Hornsat.h	/^  const Z3Subterms &   subterms;$/;"	m	class:Hornsat
subterms	include/Z3Subterms.h	/^  z3::expr_vector subterms;$/;"	m	struct:Z3Subterms
subterms	tests/TestCongruenceClosureExplain.h	/^  Z3Subterms      subterms;$/;"	m	class:TestCongruenceClosureExplain
tag	include/CurryNode.h	/^  const PendingTag tag;$/;"	m	struct:PendingElement
target	include/UnionFindExplain.h	/^  EqClass source, target;$/;"	m	struct:ExplainEquation
testCongClosureExpl	tests/cong_closure_expl_test.cpp	/^void testCongClosureExpl(){$/;"	f
testCongClosureExpl2	tests/cong_closure_expl_test.cpp	/^void testCongClosureExpl2(){$/;"	f
testCongClosureExpl3	tests/cong_closure_expl_test.cpp	/^void testCongClosureExpl3(){$/;"	f
testCongClosureExpl4	tests/cong_closure_expl_test.cpp	/^void testCongClosureExpl4(){$/;"	f
testCongClosureExpl5	tests/cong_closure_expl_test.cpp	/^void testCongClosureExpl5(){$/;"	f
testConsistency	tests/TestCongruenceClosureExplain.cpp	/^bool TestCongruenceClosureExplain::testConsistency(z3::expr const & e, unsigned max_iter){$/;"	f	class:TestCongruenceClosureExplain
testExplanation	tests/TestCongruenceClosureExplain.cpp	/^void TestCongruenceClosureExplain::testExplanation(unsigned n){$/;"	f	class:TestCongruenceClosureExplain
to_replace	include/FactoryCurryNodes.h	/^  std::list<CurryNode *>    to_replace;$/;"	m	class:FactoryCurryNodes
traversePartA	src/Rename.cpp	/^void traversePartA(z3::expr const & e,$/;"	f
traversePartB	src/Rename.cpp	/^void traversePartB(z3::expr const & e,$/;"	f
uf	include/CongruenceClosure.h	/^  UnionFind & uf;$/;"	m	class:SignatureTable
uf	include/CongruenceClosure.h	/^  UnionFindExplain & uf;$/;"	m	class:CongruenceClosure
uf	include/EUFInterpolant.h	/^  UnionFindExplain uf;$/;"	m	class:EUFInterpolant
uf	include/HornClause.h	/^  UnionFind &       uf;$/;"	m	class:HornClause
uf	tests/TestCongruenceClosureExplain.h	/^  UnionFindExplain uf;$/;"	m	class:TestCongruenceClosureExplain
ufe	include/CongruenceClosureExplain.h	/^  UnionFindExplain &  ufe;$/;"	m	class:CongruenceClosureExplain
unionReverseEdges	src/UnionFindExplain.cpp	/^void UnionFindExplain::unionReverseEdges(EqClass target, EqClass source){$/;"	f	class:UnionFindExplain
unionupdate	src/Hornsat.cpp	/^void Hornsat::unionupdate(UnionFind & uf,$/;"	f	class:Hornsat
uniqueSize	src/FactoryCurryNodes.cpp	/^const unsigned FactoryCurryNodes::uniqueSize() const {$/;"	f	class:FactoryCurryNodes
unsigned_hasher	include/FactoryCurryNodes.h	/^  std::hash<unsigned>                         unsigned_hasher;$/;"	m	class:FactoryCurryNodes
update	src/Hornsat.cpp	/^void Hornsat::update(CongruenceClosure & cc, std::list<unsigned> & pending,$/;"	f	class:Hornsat
updateAllIds	src/CurryNode.cpp	/^void CurryNode::updateAllIds(unsigned new_id){$/;"	f	class:CurryNode
updateCommon	src/CurryNode.cpp	/^void CurryNode::updateCommon(bool new_is_common){$/;"	f	class:CurryNode
updateConstId	src/CurryNode.cpp	/^void CurryNode::updateConstId(unsigned new_const_id){$/;"	f	class:CurryNode
updateLeft	src/CurryNode.cpp	/^void CurryNode::updateLeft(CurryNode * new_left){$/;"	f	class:CurryNode
updatePreds	src/FactoryCurryNodes.cpp	/^void FactoryCurryNodes::updatePreds(CurryNode * from, CurryNode * to){$/;"	f	class:FactoryCurryNodes
updateRight	src/CurryNode.cpp	/^void CurryNode::updateRight(CurryNode * new_right){$/;"	f	class:CurryNode
updateZ3Id	src/CurryNode.cpp	/^void CurryNode::updateZ3Id(unsigned new_z3_id){$/;"	f	class:CurryNode
updateZ3IdNotDefinedAndCommon	src/FactoryCurryNodes.cpp	/^void FactoryCurryNodes::updateZ3IdNotDefinedAndCommon(const Z3Subterms & subterms){$/;"	f	class:FactoryCurryNodes
use_list	include/CongruenceClosureExplain.h	/^  UseList     use_list;$/;"	m	class:CongruenceClosureExplain
val	include/Hornsat.h	/^  bool val;$/;"	m	struct:Literal
visited	include/Z3Subterms.h	/^  std::vector<bool> visited;$/;"	m	struct:Z3Subterms
z3Explain	src/CongruenceClosureExplain.cpp	/^Z3EquationPointers CongruenceClosureExplain::z3Explain(const z3::expr & lhs, const z3::expr & rhs){$/;"	f	class:CongruenceClosureExplain
z3_id	include/CurryNode.h	/^  unsigned id, z3_id, const_id;$/;"	m	class:CurryNode
z3_id_defined	include/CurryNode.h	/^  bool z3_id_defined = false;$/;"	m	class:CurryNode
z3_repr	src/CongruenceClosureExplain.cpp	/^z3::expr CongruenceClosureExplain::z3_repr(unsigned i){$/;"	f	class:CongruenceClosureExplain
z3_repr	src/CongruenceClosureExplain.cpp	/^z3::expr CongruenceClosureExplain::z3_repr(z3::expr const & e){$/;"	f	class:CongruenceClosureExplain
~ClassListPos	include/Hornsat.h	/^  ~ClassListPos(){$/;"	f	struct:ClassListPos
~Clause	include/Hornsat.h	/^  ~Clause(){$/;"	f	struct:Clause
~CongruenceClosure	src/CongruenceClosure.cpp	/^CongruenceClosure::~CongruenceClosure(){$/;"	f	class:CongruenceClosure
~CongruenceClosureDST	src/CongruenceClosureDST.cpp	/^CongruenceClosureDST::~CongruenceClosureDST(){$/;"	f	class:CongruenceClosureDST
~CongruenceClosureExplain	src/CongruenceClosureExplain.cpp	/^CongruenceClosureExplain::~CongruenceClosureExplain(){$/;"	f	class:CongruenceClosureExplain
~CongruenceClosureNO	src/CongruenceClosureNO.cpp	/^CongruenceClosureNO::~CongruenceClosureNO(){$/;"	f	class:CongruenceClosureNO
~EUFInterpolant	src/EUFInterpolant.cpp	/^EUFInterpolant::~EUFInterpolant(){$/;"	f	class:EUFInterpolant
~FactoryCurryNodes	src/FactoryCurryNodes.cpp	/^FactoryCurryNodes::~FactoryCurryNodes(){$/;"	f	class:FactoryCurryNodes
~HornClause	src/HornClause.cpp	/^HornClause::~HornClause(){$/;"	f	class:HornClause
~HornClauses	src/HornClauses.cpp	/^HornClauses::~HornClauses(){$/;"	f	class:HornClauses
~Hornsat	src/Hornsat.cpp	/^Hornsat::~Hornsat(){$/;"	f	class:Hornsat
~Literal	include/Hornsat.h	/^  ~Literal(){$/;"	f	struct:Literal
~LookupTable	include/CongruenceClosureExplain.h	/^  ~LookupTable(){$/;"	f	class:LookupTable
~Match	src/Match.cpp	/^Match::~Match() {$/;"	f	class:Match
~SignatureTable	include/CongruenceClosure.h	/^  ~SignatureTable(){$/;"	f	class:SignatureTable
~UnionFind	src/UnionFind.cpp	/^UnionFind::~UnionFind(){$/;"	f	class:UnionFind
~UnionFindExplain	src/UnionFindExplain.cpp	/^UnionFindExplain::~UnionFindExplain(){$/;"	f	class:UnionFindExplain
