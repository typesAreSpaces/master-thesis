\begin{algorithm}[!ht]
  \caption{Modified Congruence Closure with Explanation Algorithms - Propagate}
  \linespread{\separationline}\selectfont
  \begin{algorithmic}[2]
    \Procedure {Propagate} {\text{ }}
    \While {Pending is non-empty}
    \State {Remove E of the form a=b or (apply(a1, a2) = a, apply(b1, b2) = b) from Pending}
    \If {$Representative(a) \neq Representative(b)$ and w.l.o.g. $|ClassList(Representative(a))| \leq |ClassList(Representative(b))|$}
    \State {oldReprA := Representative(a);}
    \State {Insert edge $a \rightarrow b$ labelled with E into the proof forest;}
    \For {each c in ClassList(oldReprA)}
    \State {set Representative(c) to Representative(b)}
    \State {move c from ClassList(oldReprA) to ClassList(Representative(b))}
    \For {each pointer L in ClassList(u)}
    \If {H[L].val = false}
    \State {set the field H[L].lclass or H[L].rclass pointed to by p to Representative(b)}
    \If {H[L].lclass = H[L].rclass}
    \State {queue := push(L, queue);}
    \State {H[L].val := true}
    \EndIf
    \EndIf
    \EndFor
    \EndFor
    \For {each apply(c1, c2) = c in UseList(oldReprA)}
    \If {Lookup(Representative(c1), Representative(c2)) is some apply(d1, d2) = d}
    \State {add (apply(c1, c2) = c, apply(d1, d2) = d) to Pending;}
    \State {remove apply(c1, c2) = c from UseList(oldReprA);}
    \Else
    \State {set Lookup(Representative(c1), Representative(c2)) to apply(c1, c2) = c;}
    \State {move apply(c1, c2) = c from UseList(oldReprA) to UseList(Representative(b));}
    \EndIf
    \EndFor 
    \EndIf
    \EndWhile
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
