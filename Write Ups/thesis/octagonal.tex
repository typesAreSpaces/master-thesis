\chapter{Interpolation algorithm for UTVPI Formulas}

This theory appears heavily in formal methods dealing
with abstract domains introduced in \cite{journals/corr/abs-cs-0703084}.
The decision problem consists of checking the satisfiability
of a particular fragment of $LIA(\mathbb{Z})$. The fragment 
consists on conjunctions of inequalities with at most
two variables which integers coefficients are restricted
to $\{-1, 0, 1\}$. Efficient algorithms are found in the literature
for both the satisfiability problem \cite{10.1007/11559306_9} as well as 
for interpolation \cite{10.1007/978-3-642-02959-2_15} of the theory. 
Eventhough this fragment looks severely constrained, 
it has been used for a range of applications where problems can 
be modelled using this particular kind of literals.

The algorithm in \cite{KAPUR2017} follows a similar approach to the
interpolation algorithm for EUF in the sense that the attention is
given to one of the formulas in the interpolation pair \footnote {
This implementation uses the first formula of the pair. }
Other approaches towards interpolation follow graph-based algorithms.
The idea combines the reduction of UTVPI formulas to difference 
logic \cite{journals/corr/abs-cs-0703084} and a cycle 
detection of maximal size \cite{10.1007/978-3-642-02959-2_15}.

\section{Algorithm}

The algorithm proposed \cite{KAPUR2017} uses inference rules
to close the relation and eliminate the uncommon variables from the
A-part of the input formula. The rules are the following:

\begin{center}
  \begin{prooftree}
    \hypo[]{s_1 x_1 + s_2 x_2 \leq c}
    \hypo[]{s_1 = s_2 \in \{ -1, 0, 1 \}$ and $x_1 = x_2 \in Vars}
    \infer2[Normalize]{s_1 x_1 \leq \floor{\frac{c}{2}}}
  \end{prooftree}

  \begin{prooftree}
    \hypo[]{s_1 x_1 + s_2 x_2 \leq c_1}
    \hypo[]{- s_2 x_2 + s_3 x_3 \leq c_2}
    \infer2[Elim]{s_1 x_1 + s_3 x_3 \leq c_1 + c_2}
  \end{prooftree}
\end{center}

The algorithm normalizes the inequalities at the beginning as 
a preprocessing step and applies the Elim rule whenever it is
possible until no more uncommon variables remain in the 
input formula. Hence, having an efficient representation of 
the inequalities and detecting matches (like pivots for
resolution steps) is important for an efficient implementation.
To achieve this goal we implemented to an encoding of 
the inequalities using natural numbers, an array of 
numbers indexed by the numeral representation of the  inequalities
which keeps track of the minimum bound of the encoded inequality,
and a data structure to keep track of the signs of variables
in the inequalities for efficient matching.

%\input{proof_of_main_theorem_octagons}

\section{Implementation}

In order to obtain a bijection between UTVPI inequalities and
natural numbers, first we define an ordering on the inequalities
and notice some invariants of the latter. 

We encode the term $\pm x_m \pm x_n$ using the point
$(\pm m, \pm n) \in \mathbb{Z}^2$. Let $TermToPoint$ be the map
that $\pm x_m \pm x_n \mapsto (\pm m, \pm n)$.The variable $x_0$ is a
\emph{dummy variable} that acts as a place holder for 0. 
Additionally, we will restrict the terms/pairs such that the absolute
value of the first index variable is strictly greater than the
absolute value of the second index variable \footnote{This condition also
  avoids the problem of keeping track of variable duplication in 
the inequality.} since addition is commutative, except for the point
(0, 0) which encodes the inequality with no variables.

We define the following orderings relevant for the terms of the form
$\pm x_m \pm x_n$.

\begin{definition} 
  Let $\succ_m$ be an ordering on the integers such that $a \succ_m b$
  if and only $|a| > |b|$ or ($|a| = |b|$ and $a > b$) where $>$ is the
  standard ordering on integers.

  Let $\succ_p$ be an ordering on pair of integers such that 
  $(m_1, n_1) \succ_p (m_2, n_2)$ if and only if $m_1 \succ_m m_2$
  or ($m_1 = m_2$ and $n_1 \succ_m n_2$).

  Let $\succ_t$ be an ordering on terms of the form $\pm x_m \pm x_n$
  such that $t_1 \succ_t t_2$ if and only if $TermToPoint(t_1) \succ_p TermToPoint(t_2)$
\end{definition}

\begin{example}
  The first 32 elements (in ascending order w.r.t. $\succ_t$) of UTVPI inequalities
  \footnote{For readability purposes we include the bound for the UTVPI term }
  are the following:

  $x_{0} + x_{0} \leq b_{0}$

  $-x_{1} + x_{0} \leq b_{1}, x_{1} + x_{0} \leq b_{2}$ 

  $-x_{2} + x_{0} \leq b_{3}, -x_{2} - x_{1} \leq b_{4}, -x_{2} + x_{1} \leq b_{5}, x_{2} + x_{0} \leq b_{6}, x_{2} - x_{1} \leq b_{7}, x_{2} + x_{1} \leq b_{8}$

  $-x_{3} + x_{0} \leq b_{9}, -x_{3} - x_{1} \leq b_{10}, -x_{3} + x_{1} \leq b_{11}, -x_{3} - x_{2} \leq b_{12}, -x_{3} + x_{2} \leq b_{13},x_{3} + x_{0} \leq b_{14}, x_{3} - x_{1} \leq b_{15}, x_{3} + x_{1} \leq b_{16}, x_{3} - x_{2} \leq b_{17}, x_{3} + x_{2} \leq b_{18}$
\end{example}

From the example, we notice that we can group/order the inequalities by groups using the first
index. The first element of the $i^{th}$ group corresponds to the $2(i-1)^2 + 1$ element in the 
$\succ_t$ order. The observation follows from an inductive argument since there are 
$2(1 + 2(i-1))$ elements in the $i^{th}$ group. It is also straight forward to find the
position of the first element in the second half of any group. With the above information
it is possible to find the map between UTVPI terms and naturals numbers.

This bijection allows us to implement a data 
structure based on a vector of integers extended
with $\pm \infty$ which encodes the upper bounds 
for the $i^{th}$ inequality present in the 
input formula. For initialization purpose all 
the entries in this vector are set to
$\infty$ and these values are updated accordingly 
to keep track to the minimum possible value 
for the inequality after the application of the 
inference rules mentioned at the
introduction of the section.

\begin{algorithm}
  \caption{UTVPI constructor}
  \linespread{\separationline}\selectfont
  \begin{algorithmic}[2]
    \Procedure {UTVPI constructor} {position : integer}

    \State coefficient1 = 0
    \State coefficient2 = 0
    \State varindex1 = 0
    \State varindex2 = 0
    \If {position = 0}
    \State return
    \EndIf

    \State varindex1 = $\sqrt{\frac{position - 1}{2}} + 1$
    \State initial\_group\_position = $2*(varindex1-1)^2 + 1$
    \State half\_size\_group = $2*varindex1-1$

    \If {position $\leq$ initial\_group\_position + half\_size\_group}
    \State coefficient1 = -1
    \If {position = initial\_group\_position}

    \State coefficient2 = 0
    \State varindex2 = 0
    \State return
    \EndIf
    \State separation = position - initial\_group\_position
    \State varindex2 = $\frac{separation - 1}{2} + 1$
    \If {mod separation 2 = 0}
    \State coefficient2 = 1
    \State return
    \EndIf
    \State coefficient2 = -1
    \State return
    \EndIf

    \State coefficient1 = 1
    \If {position = initial\_group\_position + half\_size\_group + 1}
    \State coefficient2 = 0
    \State varindex2 = 0
    \State return
    \EndIf
    \State separation = position - initial\_group\_position - half\_size\_group - 1
    \State varindex2 = $\frac{separation - 1}{2} + 1$
    \If {mod separation 2 = 0}
    \State coefficient2 = 1
    \State return
    \EndIf
    \State coefficient2 = -1
    \State return
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{UTVPI position}
  \linespread{\separationline}\selectfont
  \begin{algorithmic}[2]
    \Procedure {UTVPI position} { $s_1 x_{m_1} + s_2 x_{m_2}$ : UTVPI term}

    \State initial\_group\_position = $2*(m_1 -1)^2 + 1$

    \If { $s_1 = -1$ }
    \State sign\_a\_offset = 0
    \Else
    \If { $s_1 = 0$ }
    \State return 0
    \Else
    \If { $s_1 = 1$ }
    \State sign\_a\_offset = $2*(m_1 - 1) + 1$
    \EndIf
    \EndIf
    \EndIf

    \If { $s_2 = -1$ }
    \State sign\_b\_offset = $1 + 2*(m_2 -1)$
    \Else
    \If { $s_2 = 0$ }
    \State sign\_b\_offset = 0
    \Else
    \If { $s_2 = 1$ }
    \State sign\_b\_offset = $2*m_2$
    \EndIf
    \EndIf
    \EndIf

    \State return initial\_group\_position + sign\_a\_offset + sign\_b\_offset

    \EndProcedure
  \end{algorithmic}

\end{algorithm}


\section{Evaluation}

TODO.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
