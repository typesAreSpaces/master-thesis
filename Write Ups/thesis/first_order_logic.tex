\section{First-Order Predicate Logic}

\subsection{Language}
A language is a collection of symbols of different sorts equipped with a rule of composition that effectively tells us how to recognize elements that belong to the language \cite{DBLP:books/daglib/0080654}. In particular, a first-order language is a language that expresses boolean combinations of predicates using terms (constant symbols and function applications). In mathematical terms, 

\begin{definition}
 A first-order language (also denoted signature) is a triple $\langle \mathfrak{C}, \mathfrak{P}, \mathfrak{F} \rangle$ of non-logical symbols where:

\begin{itemize}
  \item $\mathfrak{C}$ is a collection of constant symbols
  \item $\mathfrak{P}$ is a collection of n-place predicate symbols
  \item $\mathfrak{F}$ is a collection of n-place function symbols
\end{itemize}

including logical symbols like quantifiers(universal ($\forall$), existential($\exists$)) logical symbols like parenthesis, propositional connectives (implication ($\rightarrow$), conjunction ($\land$), disjunction ($\lor$), negation ($\neg$)), and a countable number of variables \emph{Vars} (i.e. $\emph{Vars} = \{v_1, v_2, \dots\}$).

The rules of composition distinguish two objects, \emph{terms} and \emph{formulas}, which are defined recursively as follows:

\begin{itemize}
  \item Any variable symbol or constant symbol is a term.
  \item If $t_1, \dots, t_n$ are terms and $f$ is an n-ary function symbol, then $f(t_1, \dots, t_n)$ is also a term.
  \item If $t_1, \dots, t_n$ are terms and $P$ is an n-ary predicate symbol, then $P(t_1, \dots, t_n)$ is formula.
  \item If $x$ is a variable and $\psi, \varphi$ are formulas, 
    then $(\neg \psi), (\forall x . \psi), (\exists x . \psi)$ 
    and $(\psi \square \varphi)$ are formulas where $\square \in \{\rightarrow, \land, \lor\}$
  \item No other expression in the language can be considered terms nor formulas if such expressions are not obtained by the previous rules.
\end{itemize}

For notation purposes, we compactly represent a tuple $\langle x_1, \dots, x_n \rangle$ of variables as
$\cev{x}$. Abusing the notation, a formula of the form 
$\forall \cev{x} . \phi(\cev{x})$ (resp. $\exists \cev{x} . \phi(\cev{x})$)
denotes the formula $\forall x_1 . \forall x_2 \dots \forall x_n . \phi(x_1, \dots, x_n)$
(resp. $\exists x_1 . \exists x_2 \dots \exists x_n . \phi(x_1, \dots, x_n)$)

\end{definition}

\subsection{Semantics}

In order to define a notion of truth in a first-order language is necessary to associate for each non-logical symbol (since logical symbols have established semantics from propositional logic) a denotation or mathematical object and an \emph{assignment} to the collection of variables. The two previous components are part of an \emph{structure} \cite{DBLP:books/daglib/0076838} (or interpretation \cite{DBLP:books/daglib/0080654}) for a first-order language.

\begin{definition}
  Given a first-order language $\mathfrak{L}$, an interpretation $\mathfrak{I}$ is a pair $(\mathfrak{A}, \mathfrak{J})$, where $\mathfrak{A}$ is a non-empty domain (set of elements) and $\mathfrak{J}$ is a map that associates to the non-logical symbols from $\mathfrak{L}$ the following elements:
  \begin{itemize}
    \item $\mathfrak{I}$ assigns to each constant symbol $c$
      an elements $c^\mathfrak{A} \in \mathfrak{A}$
    \item $\mathfrak{I}$ assigns to each n-place
      predicate symbol $P$ an n-ary relation 
      $P^{\mathfrak{A}} \subseteq \mathfrak{A}^n$
    \item $\mathfrak{I}$ assigns to each n-place function
      symbol $f$ an n-ary operation $f^\mathfrak{A}$
      on $\mathfrak{A}$, i.e. $f^\mathfrak{A} : 
      \mathfrak{A}^n \rightarrow \mathfrak{A}$
  \end{itemize}

  An assignment $s : Vars \rightarrow \mathfrak{A}$ is a 
  map between variables to elements from the domain of 
  the interpretation.
\end{definition}

With the definition of interpretation $\mathfrak{I}$ and assignment $s$, we can recursively define a notion of \emph{satisfiability} (denoted by the symbol $\models_{\mathfrak{I}, s} $) as a free extension from atomic predicates (function application of predicates) to general formulas as described in \cite{DBLP:books/daglib/0076838}. For the latter, we need to extend the assignment function to all terms in the language.

\begin{definition}
  Let $\mathfrak{I} = (\mathfrak{A}, \mathfrak{J})$ be an interpretation and $s$ an assignment for a given language,
  Let $\bar{s} : Terms \rightarrow A$ be defined recursively as follows:
  \begin{itemize}
    \item $\bar{s}(c) = c^\mathfrak{J}$
    \item $\bar{s}(f(t_1, \dots, t_n)) = f^\mathfrak{J}(\bar{s}(t_1), \dots, \bar{s}(t_n))$
  \end{itemize}
\end{definition}

Notice that the extension of $s$ depends on the interpretation used.

\begin{definition}
  Given an interpretation $\mathfrak{I} = (\mathfrak{A}, \mathfrak{J})$, an assignment $s$, and $\psi$ a formula, we define $\mathfrak{I} \models_s \psi$ (read $\psi$ is satisfiable under interpretation $\mathfrak{I}$ and assignment $s$) recursively as follows:
  \begin{itemize}
    \item $\models_{\mathfrak{I}, s} P(t_1, \dots, t_n)$ 
      if and only if 
      $\langle
      \bar{s}(t_1), \dots, \bar{s}(t_n) \rangle 
      \in P^{\mathfrak{J}}$
    \item $\models_{\mathfrak{I}, s} \neg \psi$ if and only if  it is not the case that $\models_{\mathfrak{I}, s}   \psi$
    \item $\models_{\mathfrak{I}, s} \psi \land \varphi$ if and only if $\models_{\mathfrak{I}, s}  \psi$ and $   \models_{\mathfrak{I}, s}  \varphi$
    \item $   \models_{\mathfrak{I}, s}  \psi \lor \varphi$ if and only if $   \models_{\mathfrak{I}, s}  \psi$ or $   \models_{\mathfrak{I}, s}  \varphi$
    \item $   \models_{\mathfrak{I}, s}  \psi \rightarrow \varphi$ if and only if $   \models_{\mathfrak{I}, s}  \neg \psi$ or $   \models_{\mathfrak{I}, s}  \varphi$
    \item $   \models_{\mathfrak{I}, s}  \forall x . \psi$ if and only if for every $d \in \mathfrak{A},    \models_{\mathfrak{I}, s_{x \mapsto d}} \psi$, where $s_{x \mapsto d} : Vars \rightarrow \mathfrak{A}$ is reduct of $s$ under $Vars \setminus \{x\}$ and $s_{x \mapsto d}(x) = d$
    \item $   \models_{\mathfrak{I}, s}  \exists x . \psi$ if and only if exits $d \in \mathfrak{A},    \models_{\mathfrak{I}, s_{x \mapsto d}} \psi$, where $s_{x \mapsto d}$ is defined as in the previous item.
  \end{itemize}

  If an interpretation and assignment satisfies a formula, then we say that the interpretation and the assignment are a model for the respective formula. A collection of formulas are satisfied by an interpretation and assignment if these model each formula in the collection.

  A formula $\psi$ is said to be a \emph{valid} 
  formula of the interpretation $\mathfrak{I}$ 
  when $\models_{\mathfrak{I}, s} \psi$ for all 
  possible assignments $s$.

  Additionally, if all the models $(\mathfrak{I},
  s)$ in a language of a collection of formulas 
  $\Gamma$ satisfy a formula $\psi$, then we say 
  that $\Gamma$ logically implies $\psi$ 
  (written $\Gamma \models \psi$). For the 
  latter, $\psi$ is said to be a \emph{valid} 
  formula of the model $(\mathfrak{I}, s)$.

\end{definition}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
