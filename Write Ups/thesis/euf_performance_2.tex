\subsection{Performance comparison with iZ3 and MathSat}\label{performance_euf}

This section discusses a benchmark of interpolant generation
for the EUF theory, which it will allow us to test 
our implementation and contrast the execution 
time with other interpolant generation
algorithms from Z3 and Mathsat.

\subsubsection{Benchmark description}

The benchmark uses the following parameters:

\begin{itemize}
  \item $i$ stands for the number of constants
  \item $j$ stands for the number of function symbols
    with arity between 2 and 3
  \item $k$ stands for limit for random terms to consider
    in the problem
  \item $n$ stands for the equations/dis-equations in the
    A-part
\end{itemize}

The benchmark generates a pair of two unsatisfiable formulas
in the EUF language from a fixed theory with the following parameters:

\begin{equation*}
  S = \{ c_1, \dots, c_i, f_1, \dots, f_j \}
\end{equation*}

where $i, j$ are random integer numbers. Using the $S$, we
enumerate the grounded terms $G$ in $S$ and assign a natural 
number to each number denoting its position in the enumeration.

We generate $n$ random equations/dis-equations from the signature $S$ 
such that this
collection of formulas is consistent for the $A-part$ of
the input problem. 
The latter is implemented using a $z3: :solver$ to ensure 
this condition.
The equations/dis-equations are of the form:

\begin{equation*}
  position(k_1, S) = position(k_2, S) \text{ , or } position(k_1, S) \neq position(k_2, S) 
\end{equation*}

where $position(k, S)$ denotes the $k^{th}$ element in $G$. The 
integers $k_1, k_2$ are chosen uniformly at random from a
distribution of integer values $\{0, \dots, k\}$, 
where $k$ is a parameter of the benchmark.

Next we randomly generate a second set of consistent 
equations/dis-equations (B-Part) until the $A-part$ and the
$B-part$ are inconsistent using a second $z3: :solver$.

\begin{figure}[!ht]
  \centering
  \begin{BVerbatim}[fontsize=\tiny]
    A part formulas:
    (ast-vector
      (distinct (f_0 x_6 x_0 x_0 x_0) (f_0 x_9 x_8 x_0 x_0))
      (= (f_0 x_8 x_1 x_0 x_0) (f_0 x_1 x_0 x_0 x_0))
      (= (f_0 x_5 x_2 x_0 x_0) (f_0 x_4 x_5 x_0 x_0))
      (distinct (f_0 x_6 x_2 x_0 x_0) (f_0 x_9 x_3 x_0 x_0))
      (distinct (f_0 x_4 x_7 x_0 x_0) x_7)
      (= (f_0 x_5 x_5 x_0 x_0) (f_0 x_8 x_1 x_0 x_0))
      (= (f_0 x_2 x_6 x_0 x_0) (f_0 x_9 x_3 x_0 x_0))
      (= x_7 (f_0 x_1 x_6 x_0 x_0))
      (= (f_0 x_1 x_4 x_0 x_0) (f_0 x_6 x_3 x_0 x_0))
    (= x_8 (f_0 x_2 x_6 x_0 x_0)))
    B part formulas:
    (ast-vector
      (= (f_0 x_6 x_8 x_0 x_0) (f_0 x_9 x_7 x_0 x_0))
      (distinct (f_0 x_2 x_6 x_0 x_0) (f_0 x_7 x_0 x_0 x_0))
      (distinct (f_0 x_7 x_7 x_0 x_0) x_4)
      (distinct (f_0 x_6 x_6 x_0 x_0) (f_0 x_3 x_8 x_0 x_0))
      (= (f_0 x_2 x_5 x_0 x_0) (f_0 x_7 x_6 x_0 x_0))
      (= (f_0 x_6 x_0 x_0 x_0) (f_0 x_2 x_3 x_0 x_0))
      (= (f_0 x_3 x_3 x_0 x_0) (f_0 x_6 x_5 x_0 x_0))
      (distinct (f_0 x_8 x_8 x_0 x_0) (f_0 x_5 x_1 x_0 x_0))
      (distinct (f_0 x_7 x_8 x_0 x_0) (f_0 x_9 x_1 x_0 x_0))
      (= (f_0 x_8 x_8 x_0 x_0) (f_0 x_7 x_2 x_0 x_0))
      (distinct (f_0 x_2 x_1 x_0 x_0) (f_0 x_3 x_2 x_0 x_0))
      (= (f_0 x_5 x_3 x_0 x_0) (f_0 x_7 x_4 x_0 x_0))
      (distinct (f_0 x_1 x_2 x_0 x_0) (f_0 x_5 x_3 x_0 x_0))
      (= (f_0 x_1 x_7 x_0 x_0) (f_0 x_3 x_6 x_0 x_0))
      (distinct (f_0 x_3 x_2 x_0 x_0) (f_0 x_8 x_7 x_0 x_0))
      (= (f_0 x_2 x_8 x_0 x_0) x_4)
      (= (f_0 x_2 x_2 x_0 x_0) (f_0 x_8 x_3 x_0 x_0))
      (= (f_0 x_1 x_1 x_0 x_0) (f_0 x_8 x_8 x_0 x_0))
      (distinct (f_0 x_3 x_2 x_0 x_0) (f_0 x_8 x_3 x_0 x_0))
      (= (f_0 x_2 x_8 x_0 x_0) (f_0 x_6 x_3 x_0 x_0))
      (distinct (f_0 x_5 x_6 x_0 x_0) (f_0 x_0 x_1 x_0 x_0))
      (= (f_0 x_7 x_3 x_0 x_0) (f_0 x_7 x_0 x_0 x_0))
      (distinct (f_0 x_0 x_3 x_0 x_0) (f_0 x_8 x_3 x_0 x_0))
      (distinct (f_0 x_8 x_2 x_0 x_0) (f_0 x_2 x_7 x_0 x_0))
      (distinct (f_0 x_9 x_1 x_0 x_0) (f_0 x_5 x_0 x_0 x_0))
      (distinct (f_0 x_0 x_4 x_0 x_0) (f_0 x_0 x_5 x_0 x_0))
      (distinct (f_0 x_5 x_5 x_0 x_0) (f_0 x_2 x_8 x_0 x_0))
      (= (f_0 x_6 x_3 x_0 x_0) (f_0 x_3 x_0 x_0 x_0))
      (= (f_0 x_3 x_8 x_0 x_0) (f_0 x_0 x_8 x_0 x_0))
      (distinct (f_0 x_8 x_0 x_0 x_0) (f_0 x_5 x_5 x_0 x_0))
      (= (f_0 x_6 x_6 x_0 x_0) (f_0 x_4 x_5 x_0 x_0))
      (distinct (f_0 x_4 x_3 x_0 x_0) x_5)
      (distinct x_8 (f_0 x_3 x_3 x_0 x_0))
      (= (f_0 x_6 x_3 x_0 x_0) (f_0 x_3 x_6 x_0 x_0))
      (= (f_0 x_4 x_1 x_0 x_0) (f_0 x_5 x_6 x_0 x_0))
      (= x_7 (f_0 x_0 x_3 x_0 x_0))
      (distinct (f_0 x_1 x_3 x_0 x_0) (f_0 x_8 x_2 x_0 x_0))
      (= (f_0 x_2 x_1 x_0 x_0) (f_0 x_6 x_8 x_0 x_0))
      (= x_3 (f_0 x_9 x_7 x_0 x_0))
      (= (f_0 x_3 x_7 x_0 x_0) x_8)
    (= (f_0 x_3 x_7 x_0 x_0) (f_0 x_6 x_2 x_0 x_0)))
  \end{BVerbatim}
  \caption{Typical example of benchmark used}
\end{figure}

\subsubsection{Experimental results}

We designed this problem because it is not trivial to 
compute a  uniform/interpolant due to randomness of the
problem. This problem was executed $100$ times
with parameters (i = 10, j = 5, k = 100, n = 10) and 
(i = 20, j = 10, k = 100, n = 40)
using a computer desktop
equipped with an Intel i7-9700 @ 4.70 GHz processor 
and 16 GB of RAM. 

The following graph reports the time needed
by our implementation, iZ3, and the interpolation 
generation algorithm from Mathsat. 
It is well known that both iZ3 and Mathsat does not
compute uniform interpolants. Regardless, the benchmark
was used with the purpose to compare their execution time
on normal interpolants.

The time was
measured using a bash script which takes the difference
of the output produced by the UNIX utility $date +`\%s.\%N'$ 
at the beginning and at the end of the execution of the 
tested algorithms.

\begin{figure}
  \centering
  \includegraphics[scale=0.7]{figures/eufi_performance_graph_10_5_3_10_100}
  \caption{Performance comparison graph of EUF interpolant generation
  algorithms for the benchmark (i = 10, j = 5, k = 100, n = 10)}
  \label{performance_graph_euf}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[scale=0.7]{figures/eufi_performance_graph_20_10_3_40_100}
  \caption{Performance comparison graph of EUF interpolant generation
  algorithms for the benchmark (i = 20, j = 10, k = 100, n = 40)} 

  \label{performance_graph_euf_2}
\end{figure}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
