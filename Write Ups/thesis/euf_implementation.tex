\section{Implementation}

The description of the uniform interpolation 
algorithm presented in the
previous section suggests a straight forward implementation
of the first two stages using well-known algorithms 
\cite{10.1145/322186.322198,10.1145/322217.322228} 
and data structures from the SMT
solver Z3 \cite{10.1007/978-3-540-78800-3_24} to represent 
elements from the EUF language. One particular change was 
required in the congruence closure algorithm since Kapur's 
algorithm keeps common terms as representatives
whenever common terms belong to a partition of terms induced
by the equivalence relation.

The algorithm in \cite{10.1145/322217.322228}
uses a union-find data structure to encode the equivalence classes
of the nodes in the abstract syntax tree of the input formula with 
a `modify the smaller subtree' strategy. This means that
when two nodes $u, v$ in the abstract syntax tree are
meant to be merged, the representative of the new 
combined equivalence class is the node which has a bigger
number of predecessors nodes in the abstract
syntax tree pointing to the
equivalence class of the node. The idea was to update the least
amount of nodes that possibly can change representatives
due to the most recent merge operation of the equivalence classes 
and congruence.

\begin{notation}
  Given a theory $\mathcal{E}$ and a term $u$ in the language of 
  $\mathcal{E}$, we can indicate by $[u]$ the equivalence class
  induced by $\mathcal{E}$, i.e. $[u]_{\mathcal{E}} = \{ v \in TERMS | 
  \models_{\mathcal{E}} u = v\}$. \footnote{If the theory
    is clear from context, the notation $[u]$
  denotes the equivalence class of $u$.}
\end{notation}

Our algorithm uses a different partial order to 
maintain common terms as representatives of 
the equivalence classes. The non-reflexive relation 
$\succ_{common}$ 
\footnote{The reflexive relation $u \succeq_{common} v$
  is defined as $u = v \lor u \succ_{common} v$, where
  the equality between nodes is defined as $|list(u)| = 
  |list(v)| \land u$ is a common term $\iff$ 
  $v$ is a common term.
}
is defined for all nodes $u, v$ in the abstract syntax 
tree of terms as:

\begin{equation*}
  u \succ_{common} v = \begin{cases} 
    |list(u)| > |list(v)| & \text{if }(u \text{ is a common term}\Leftrightarrow \\ 
    & v \text{ is a common term}) \\
    \text{u is a common term} & \text{otherwise}
  \end{cases}
\end{equation*}

where $list(u) = \{ f(u_1, \dots, u_n) \in \text{TERMS} 
| \exists i \in \{1, \dots, n\} \text{ such that } u_i \in [u] ] \}$

In the next section we will discuss changes proposed to 
Phase III in Kapur's algorithm. 

\subsection{New conditional elimination 
step in Kapur's algorithm}

The modification of Phase III implemented in this thesis work
combines and extends the algorithms and data structures introduced
in \cite{GALLIER1987233, 10.1007/978-3-540-32033-3_33}.
The algorithm in \cite{GALLIER1987233} is a direct
extension of \cite{DOWLING1984267} which adapts a 
congruence closure algorithm from 
\cite{10.1145/322186.322198, 10.1145/322217.322228} in order
to update the union-find data structure maintaining the
equivalence relation between all the sub-terms in the input
formula. The implementation of the congruence closure
algorithm in \cite{10.1007/978-3-540-32033-3_33}
extends the usual $Find, Merge$ operations on the 
union-find data structure with the $Explain$ operator, 
which accomplishes the following:

\begin{itemize} \label{explain_def}
  \item[] $Explain(e, e^{'})$: if a sequence $U$ of
    unions of pairs (previous Merge operations) 
    $(e_1, e_1^{'}), \dots, (e_p, e_p^{'})$
    has taken place, it returns a subset $E$
    of $U$ if $(e, e^{'})$ belongs to the equivalence
    relation generated by $E$ and it returns $\bot$
    otherwise.
\end{itemize}

The implementation of the Explain operator requires a 
\emph{proof-tree} $P$, which is a graph data structure of disjoint
trees of pointers
of the elements in the underlying equivalence relation connected
by a directed edge if there was a Merge operation 
between the nodes, i.e. $a \rightarrow b \in edges(P)$ if and only 
$Merge(a, b)$ or $Merge(b, a)$ belongs to the sequence of 
operations executed on the union-find data structure.
Particularly, our implementation for Phase III 
only uses the representatives
constant terms from Phase II as nodes for the proof-tree.

After a $Merge(a, b)$ operation is executed between 
two nodes $a, b$ on the union-find
data structure, the proof-tree needs to be updated as follows:

\begin{itemize}
  \item Reverse all the edges from $a$ to the root
    of the tree containing $a$
  \item Add an edge between $a$ and $b$
\end{itemize}

If two nodes are congruent, then they belong to the same tree
in the proof-tree data structure. 
From \cite{10.1007/978-3-540-32033-3_33}, given two congruent 
nodes $a, b$ in the union-find data structure, 
$Explain(a, b)$ can be computed by obtaining the common ancestor
$c$ of $a$ and $b$ from the respective tree $t$ in the proof-tree data
structure; thus, the sequence of unions in the explanation 
are the edges in the 
path from $a$ to $c$ in $t$ and the path from $b$ to $c$ in $t$.

\begin{example}
  Let $\{a, b, c, d, e, f, g\}$ be nodes in a union-find data
  structure and let us consider the following sequence of 
  merge operations: 1. Merge(b,d), 2. Merge(e,g), 3. Merge(a,c), 
  4. Merge(h,i), 5. Merge(a,b), 6. Merge(e,f), 7. Merge(a, e).

  The proof-tree $P$ obtained after processing the above
  Merge operations is:

  \begin{figure}[H]
    \centering
    \begin{tikzpicture}
      \node[draw, circle] (F) {$f$};
      \node[draw, circle, right=10mm of F] (E) {$e$};
      \node[draw, circle, right=10mm of E] (G) {$g$};
      \node[draw, circle, below=10mm of E] (A) {$a$};
      \node[draw, circle, right=10mm of A] (C) {$c$};
      \node[draw, circle, left =10mm of A] (B) {$b$};
      \node[draw, circle, left =10mm of B] (D) {$d$};
      \node[draw, circle, right=10mm of G] (H) {$h$};
      \node[draw, circle, right=10mm of H] (I) {$i$};
      \draw[->] (E)--(F) node [midway] {6};
      \draw[->] (G)--(E) node [midway] {2};
      \draw[->] (A)--(E) node [midway] {7};
      \draw[->] (C)--(A) node [midway] {3};
      \draw[->] (B)--(A) node [midway] {5};
      \draw[->] (D)--(B) node [midway] {1};
      \draw[->] (H)--(I) node [midway] {4};
    \end{tikzpicture}
    \caption{Example of proof-tree data structure}
  \end{figure}

  Using the above proof-tree data structure we can answer
  the following queries:

  \begin{itemize}
    \item Explain(c, g) = 2. Merge(e, g), 3. Merge(a, c), 7. Merge(a, e)
    \item Explain(c, d) = 1. Merge(b, d), 3. Merge(a, c), 5. Merge(a, b)
    \item Since $h$ and $b$ are not congruent, the
      trees containing $h$ and $b$ are disjoint.
  \end{itemize}

\end{example}

If the EUF signature of the input 
equations does not contain functional symbols, 
the $Explain$ operation from \cite{10.1007/978-3-540-32033-3_33} 
returns the minimal subset of $E$. Nonetheless, such
assertion is not guaranteed when the signature
includes functional symbols.

The motivation behind the combination of 
Gallier's data structure and the congruence 
closure algorithm with explanations is twofold: 

\begin{itemize}
  \item[] 1. We merge the nodes 
    in an equivalence
    relation corresponding to the left hand side 
    and right hand side terms of
    common equations inside the antecedents of 
    the Horn clauses obtained in Phase II.
    Additionally, we update the equivalence relation 
    structure by using the equation propagation mechanism
    from the congruence closure algorithm and 
    the implicational propagation component 
    from Gallier's structure.
  \item[] 2. The Explain operator from
    \cite{10.1007/978-3-540-32033-3_33} is recursively 
    used to construct the antecedent of Horn clauses during the 
    conditional replacement step. 
    Thus, the MERGE operation in \cite{GALLIER1987233}
    updates the proof-tree data structure
    from \cite{10.1007/978-3-540-32033-3_33} as well.
\end{itemize}

The thesis work accomplishes the previous
points by implementing the following:

1. The data structures used are
the following:

\begin{itemize}
  \item Union-find data structure: a set of disjoint
    trees which root serves as the representative 
    element for each equivalence class.
  \item Proof-tree data structure: a directed graph of pointers
    of elements in the union-fund data structure.
  \item Graph of terms: a abstract syntax tree encoding
    information about the terms in the input formula.
  \item Graph of Horn clauses: a directed graph of equations
    where two nodes $a, b$ are connected if there
    exists a Horn clause $h$ in input formula such that 
    $a \in antecedent(h)$ and $b = head(h)$. Following
    \cite{GALLIER1987233}, this data structure uses
    for each Horn clause $h$: a field number $numargs$ keeping 
    track of the number of equations $a = b$ in the antecedent of $h$
    such that $a$ and $b$ do not belong to the same 
    equivalence class; a field equation $poslit$ which stores
    the head equation of the Horn clause $h$.
    For each equation $a = b$ in the abstract syntax tree of the 
    input formula, there is an array of Horn clauses $clauselist$ 
    which keeps track of the Horn clauses $h$ such that
    $a = b \in antecedent(h)$.
    in the antecedent 

\end{itemize}

2. The implemented C++ class for 
the congruence closure with explanation 
\footnote{
  A fragment of the actual code is shown
  at Section \ref{congruence_closure_label}.
} 
includes a pointer as data member to the 
class implementation
for the Gallier data structure in order to propagate 
the equational information achieved during
merges and updates due to congruence. The modified 
algorithms appear below in pseudo-code notation (Algorithm 1, Algorithm 2, and Algorithm 3):

\input{modified_unsatisfiability_testing_for_grounded_horn_clauses}
\input{modified_congruence_closure_with_explanation_algorithms_merge}
\input{modified_congruence_closure_with_explanation_algorithms_propagate}

3. We implemented the \emph{ExtendedExplain}
procedure, which given as input an equation $a = b$ 
and a temporal equivalence relation 
$\mathcal{E}$ obtained from a set of equations 
and a set of Horn clauses in an EUF language 
$\mathfrak{L}$, it returns a set $C$ of non-trivial 
common equations \footnote{We denote a trivial equation to be an 
equation of the form $x = x$ for any term $x$ in some EUF
language.} in $\mathfrak{L}$
such that
$\models_{\mathcal{E}} (\bigwedge_{h \in C} h) 
\rightarrow a = b$ if the equation $a = b$ 
belongs to the 
temporal equivalence relation $\mathcal{E}$ ; 
it returns an empty set otherwise. 
The pseudo-code
for the ExtendedExplain procedure is shown 
below (Algorithm 4):

\input{auxiliary_function_extended_explain}

Using the data structures aforementioned 
we compute a (union-find) equivalence class 
data structure, denoted \emph{temporal equivalence
class}
that together with the Horn clauses in $\psi$
obtained from Phase II
will help us to obtain common Horn clauses.
The input of this procedure is the Horn clauses $H$
in $\psi$. The procedure is the following:

Temporal Equivalence Class Algorithm: 
\label{ccc_algorithm} \\
\begin{itemize} 
  \item[] Step 1. Let $\mathcal{E}$ be the collection 
    of equivalence classes for each distinct term 
    in the abstract 
    syntaxt tree of 
    the Horn clauses in $H$.

  \item[] Step 2. Insert all the Horn clauses 
    in $H$ to the Gallier
    data structure.

  \item[] Step 3. Merge the nodes in the 
    temporal equivalence class $\mathcal{E}$ 
    corresponding 
    to the left hand side term 
    and right hand side term of the
    common equations appearing 
    in the antecedent of the Horn clauses 
    $h \in H$. Update Gallier's data structure
    accordingly.

  \item[] Step 4. Return $\mathcal{E}$ as the
    temporal equivalence class for $H$.
\end{itemize}

\begin{example}
  Let us consider a simple example where the input 
  of Horn clause is $H = \{ 
    1. a = b \land c = d \rightarrow a = c,
    2. c = e \rightarrow e = d
  \}$; $\{d, f\}$ are uncommon symbols.

  The initial temporal equivalence class is 
  $\{\{a\}, \{b\}, \{c\}, \{d\}, \{e\}, \{f\}\}$.

  Since $a = b$ and $c = e$ are common equations, 
  the temporal equivalence class updates to 
  $\{\{a, b\}, \{c, e\}, \{d\}, \{f\}\}$.
  The second Horn clause in $H$ reaches the 
  $numargs$ to 0, hence the antecedent of such
  Horn clause is added to the temporal 
  equivalence class resulting in the following:
  $\{\{a, b\}, \{c, e, d\}, \{f\}\}$.

  Since $c = d$, then the $numargs$ field of 
  the first Horn clauses 
  reaches 0, thus the equation $a = f$ is 
  processed by the algorithm. The final 
  temporal equivalence class is
  $\{\{a, b, f\}, \{c, e, d\}\}$.
\end{example}

The Find and Merge
operation takes $\mathcal{O}(1)$ amortized cost. Thus, 
the amount of work related to the temporal 
equivalence class
in the proposed algorithm take 
$\mathcal{O}(n \log n)$ 
time complexity
where $n$ denotes the number of equations in 
the graph term 
of the Horn clauses $H$.
However, the amount of work required by the 
\emph{unionupdate}
operation of Gallier data structure is 
$\mathcal{O}((2 m + n)\floor{\log n} + 1)$ 
where $m$ is the number of nodes 
in the graph representation of the Horn clauses $H$. 
In the setting of replacing Phase III of the 
algorithm for uniform interpolation,
there can be at most $O(n^2)$
of these Horn clauses due to Phase II of Kapur's 
algorithm.
Therefore, the time complexity of the conditional
congruence closure algorithm proposed is
$\mathcal{O}((m^2 + n)\log n)$.


Remark: the only equations asserted into the 
temporal equivalence class of the algorithm
above are only the common equations from 
antecedents in Horn clauses from $H$.

\subsection{Invariants of the proposed
conditional elimination step}

For the next lemmas, unless stated otherwise, let
$H$ be the Horn clauses obtained
after executing Phase II of Kapur's algorithm, and
$\mathcal{E}$ be the temporal equivalence class
computed by \ref{ccc_algorithm} using the Horn clauses
$H$.

If the equation $t_1 = t_2$ belongs
to the temporal equivalence class $E$, 
we can prove that ExtendedExplain returns
a set of common equations $C$ such that
$\models_{\mathcal{E}} (\bigwedge_{h \in C} h) \rightarrow a = b$
using the axiomatization introduced in \ref{euf_axioms} as 
inference rules with the following lemmas:

\begin{lemma} \label{existence_horn_in_explain}
  Let $\mathcal{L}$ be some EUF language, 
  and $t_1, t_2$ terms in 
  $\mathcal{L}$ such that \\
  $\models_{\mathcal{E}} t_1 = t_2$.
  If there is an uncommon equation $a = b \in$
  $Explain(t_1, t_2)$, then there exists $h \in H$ 
  such that $h$ is of the form 
  $\bigwedge_i (c_i = d_i) \rightarrow a = b$.
\end{lemma}

\begin{proof} Let us suppose by contradition that
  there is no $h \in H$ with the above description.
  By the definition of the Explain operator in 
  \ref{explain_def},
  we see that the such operator will return a
  list of all the asserted equations in the
  equivalence relation, thus $a = b$ belongs to 
  the temporal equivalence class. 
  By inspection of the proposed
  algorithm, assertions into the temporal equivalence
  relation only happen in two places: when an equation 
  in the antecedent of a Horn clause of $H$ is common, 
  or when asserting the head equation of a Horn clause
  $h \in H$ such that its $numargs$ field becomes
  zero.
  Since there is no Horn clause with head equaiton 
  $a = b$, then $a = b$ was added when 
  the algorithm processed common equations
  in the antecedent of some Horn clause. But that
  implies that $a = b$ is a common equation. 
  Contradiction, thus there exists a Horn clause
  $h \in H$ containing $a=b$ in its head equation.
\end{proof}

\begin{lemma}\label{extended_explain_common_lemma}

  Let $\mathcal{L}$ be some EUF language 
  and $t_1, t_2$ terms in 
  $\mathcal{L}$ such that \\
  $\models_{\mathcal{E}} t_1 = t_2$.
  The list of equations returned by $ExtendedExplain(t_1, t_2, 
  H, \mathcal{E})$ contains only common equations.
\end{lemma}

\begin{proof} 
  If $t_1 = t_2$ belongs to the temporal equivalence
  class $\mathcal{E}$, then there is a derivation 
  in with $t_1 = t_2$ as the last formula in the
  derivation sequence.
  Let us prove the statement by induction 
  on the length $n$ of the derivation sequence:
  
  \begin{itemize}
    \item Case $n = 1$. We distinguish two cases:
      \begin{itemize}
        \item $t_1, t_2$ are the same terms: In
          line 6, the ExtendedExplain algorithm will return 
          the empty set. Hence, the statement holds true.
        \item $t_1, t_2$ are different terms: Then the equation
          $t_1 = t_2$ was introduced as a fact in the
          induced theory, i.e. the equation $t_1 = t_2$
          was added to the temporal 
          equivalence class as a common equation belonging to 
          the antecedent of some Horn clause $h \in H$
          during the procedure building the temporal 
          equivalence class. Line 8 of the ExtendedExplain
          procedure does not contain uncommon equations.
          Line 9 returns only the set $c$ of 
          common equations.
      \end{itemize}
    \item Case $n > 1$. Then Line 8 in the
      ExtendedExplain algorithm sets $\{c, u\}$
      to be the 
      common equations ($c$) and uncommon equations ($u$)
      from the Explanation of $t_1, t_2$.
      Pick an uncommon equation $a = b$ from the 
      previous list. By lemma \ref{existence_horn_in_explain}, there
      exists a Horn clause $h \in H$ such that
      $head(h)$ is $a = b$. Since $a = b$ belongs
      to the temporal conditional equivalence 
      class, then there exists a derivation for 
      this equation which is shorter that
      the derivation for $t_1 = t_2$. Applying
      the inductive hypothesis we see that
      ExtendedExplain returns a set of common equations
      for $ExtendedExplain(a, b, H, \mathcal{E})$.
      Applying the latter to the rest of uncommon equations
      in $u$ we obtain a set of common equations, which is
      the result of Line 9 of the ExtendedExplain procedure. 
  \end{itemize}
\end{proof}

\begin{corollary} \label{commonantecedentcorollary}
  Let $H$ be a set of Horn clauses produced by 
  Phase II of Kapur's algorithm, $\mathcal{E}$ the 
  equivalence relation obtained in Phase I of Kapur's 
  algorithm, and $\mathcal{E^{'}}$ the temporal 
  equivalence relation obtained after the modified
  conditional elimination algorithm. Then
  $H \models_{\mathcal{E^{'}}} a = b$ if and only if
  $\exists \text{ common } x \subseteq 
  \bigcup_{h \in H} antecedent(h)$ such that
  $H \models_{\mathcal{E}} \bigwedge x \rightarrow a = b$.
\end{corollary}

\begin{example}
  Let us consider the input equations $\{ \\
    1. f(f(f(f(x)))) = f(f(f(f(f(x))))), 2. x = f(f(x)), 
    3. f(a) \neq a
  \}$ 
  with the 
  set of symbols to eliminate to be 
  $\{ f \}$.
  Flattening introduces the following
  new equisatisfiable equations:
  $\{
    4. f(x) = e_1, 5. f(e_1) = e_2, 
    6. f(e_2) = e_3, 7. f(e_3) = e_4,
    8. f(e_4) = e_5, 9. f(a) = e_6,
    10. x = e_2, 11. e_4 = e_5, 
    12. e_6 = a \rightarrow \bot 
  \}$. 
  Phase I simplifies the above set of equations
  using congruence closure and replacing subterms
  by representatives. The equations produced are 
  the following:
  $\{
    12. e_6 = a \rightarrow \bot, 13. f(x) = x, 
    14. f(a) = e_6
  \}$.
  Phase II introduces the following 
  Horn clauses $H$:
  $\{
    12. e_6 = a \rightarrow \bot, 13. f(x) = x, 
    15. x = a \rightarrow x = e_6,
  \}$.

  Our algorithm notices that Horn clause 15
  contains the common equation $x = a$ in the
  antecedent. Hence, the nodes representing 
  the nodes of the terms $x$ and $a$ are merged in
  the temporal equivalence relation $\mathcal{E}$.
  With the latter, the nodes representing $x$ and 
  $e_3$ is also merged because
  the \emph{numargs} of Horn clause 15 reaches
  0. By transitivity, our algorithm
  merges the nodes for the terms $e_3$ and 
  $a$ in $\mathcal{E}$ 
  since both $x = e_3,
  x = a$ belong to $\mathcal{E}$.
  The last equation decreases the 
  \emph{numargs} entry of the Horn clause
  12. Thus, $\bot$ in $\mathcal{E}$ since
  the \emph{numargs} of Horn clause 12 reaches 0.

  Since $\bot$ is considered a common symbol,
  we can find a common Horn clause $h$ 
  in $\mathcal{E}$ which contains common equations
  in its antecedent. Since Horn clause 12 has
  $\bot$ as head, we compute ExtendedExplain
  on its antecedent as follows:
  
   %\begin{itemize}
    %\item $ExtendedExplain(e_6 = a) \rightarrow \bot$
    %\item $\bigwedge \{ExtendedExplain(x = e_3), 
      %ExtendedExplain(x = a)\} \rightarrow \bot$, since
      %$x = e_3$ was added to
      %$\mathcal{E}$ by the congruence closure, 
      %$x = a$ was added to 
      %$\mathcal{E}$ at the beginning of the algorithm 
      %because it is
      %a common equation in the antecedent of a 
      %Horn clause in $H$,
      %and $Explain(e_3 = a) = \{x = e_3, x = a\}$
    %\item $\bigwedge(\{x = a\} \cup \{x = a\}) \rightarrow \bot$, 
      %since $Explain(x = e_3) = \{x = a\}$
    %\item $x = a \rightarrow \bot$, after simplification
  %\end{itemize}

  \begin{equation*}
    \begin{aligned}
      h &:= (ExtendedExplain(e_6 = a) 
      \rightarrow \bot) \\
      &= (\bigwedge \{ExtendedExplain(x = e_3), 
      ExtendedExplain(x = a)\} \rightarrow \bot) \\
      &= (\bigwedge(\{x = a\} \cup \{x = a\}) \rightarrow \bot) \\
      &= (x = a \rightarrow \bot)
    \end{aligned}
  \end{equation*}

  Hence the common Horn clause obtained from $H$
  is $(x = a \rightarrow \bot)$.

\end{example}

\subsection{New conditional replacement
step in Kapur's algorithm}

Once the temporal equivalence relation is built after 
the execution of the previous step, we can compute conditional
replacements as follows. For the latter, we will require 
the following auxiliary functions:

\input{auxiliary_function_candidates}
\input{auxiliary_function_allcandidates}

By inspection is easy to notice that $Candidates$ 
and $allCandidates$ return a set of common terms and
a set of sets of common terms respectively.

The proposed conditional replacement step produces common Horn 
clauses from previous uncommon equations and uncommon Horn 
clauses obtained in Phase II of Kapur's algorithm.
The pseudo-code of the algorithms to 
process the original equations are shown below:

\input{conditional_replacement_part_1}
\input{conditional_replacement_part_2}

\begin{lemma} \label{conditional_replacement_lemma}
  Let $Eqs := \{f(\mathfrak{a}_{i, 1}, \dots, \mathfrak{a}_{i, n}) 
  = \mathfrak{a}_i\}$ be the set of equations produced
  in Phase I of Kapur's algorithms, $H$ the set of 
  Horn clauses obtained in Phase II, and 
  $\mathcal{E^{'}}$ the 
  temporal equivalence
  relation obtained by the proposed 
  conditional replacement step.
  Executing the proposed conditional elimination step
  on $Eqs, H, \mathcal{E^{'}}$ 
  produces common Horn clauses.
\end{lemma}

\begin{proof}
  By inspecting the conditional replacement algorithm 
  in \ref{conditional_replacement_part_1_impl},
  we noticed the antecedents of the Horn clauses 
  constructed are obtained using the ExtendedExplain 
  procedure, which from lemma 
  \ref{extended_explain_common_lemma} 
  it produces a set of common equations.

  Additionally, the equations in the 
  consequent part 
  of the Horn clauses produced in the 
  conditional replacement 
  procedure are of the form:

  \begin{itemize}
    \item $\sigma_x = \sigma_y$, 
      where $\exists t_1, t_2 \in TERMS$
      such that $\sigma_x \in Candidates(t_1)$ and 
      $\sigma_y \in Candidates(t_2)$. Since the
      function $Candidates$ returns a set of 
      common equations, then all the above 
      equations are common.
    \item $\sigma_x = f(arguments_{f})$, 
      where $\exists t, f(t_1, \dots, t_n) \in TERMS$
      with $f$ a common symbol,
      such that $\sigma_x \in Candidates(t)$ and
      $f(arguments_f) \in 
      \{f(\hat{t_1}, \dots, \hat{t_n})
        |
        \hat{t_i} \in Candidates(t_i) \text{ for } 
        1 \leq i \leq n
      \}$. Similarly to the previous case, the
      function $Candidates$ returns a set of 
      common terms, thus the elements returned
      by this case are common as well.
    \item $f_x(arguments_x) = f_y(arguments_y)$, 
      using the same
      definition for $f(arguments_f)$ from 
      the previous item.
  \end{itemize}

  It is easy to see that the above 
  equations are common if any
  of the involved sets are not empty. 
  Therefore, the algorithm 
  only produces common Horn clauses.
\end{proof}

In order to process Horn clauses obtained 
from Phase II of Kapur's algorithm, we apply 
the conditional replacement step for equations
over the equations in the consequent of all 
the Horn clauses which $numargs$ entries are 
equal to 0.

\begin{lemma}
  Let $H$ be the set of Horn clauses
  obtained at the end of Phase II of Kapur's 
  algorithm with $numargs$ entry equal to 0 
  and $\mathcal{E^{'}}$ the associated
  temporal equivalence relation obtained 
  at the end of the conditional elimination 
  procedure. 
  If $h \in H$ is of the form $\bigwedge_i (a_i = b_i) 
  \rightarrow c = d$, then the Horn clauses
  $\{\bigwedge_i ExtendedExplain(a_i, b_i, H, \mathcal{E^{'}})
    \rightarrow h^{'}  | 
    h^{'} \in 
  ConditionalReplacement(c, d, H, \mathcal{E^{'}})\}$
  are common Horn clauses.
\end{lemma}

\begin{proof}
  We observe that if the $numargs$ entry of a Horn clause
  $h \in H$ is equal to 0, then 
  all the equations in the antecedent of $h$ belong 
  to the temporal equivalence relation. Thus, 
  there exists a proof in $\mathcal{E^{'}}$ for
  each of these equations. From the latter, the consequent
  of $h$ also belongs to the temporal equivalence
  relation. Using Lemmas \ref{extended_explain_common_lemma}
  and \ref{conditional_replacement_lemma} we can conclude that
  the Horn clause in the statement is a common Horn clause.
\end{proof}

\subsection{An additional application: checking
  membership of ground Horn clauses 
with Explanations}

By adding common equations
from the antecedent of the Horn clauses during the 
conditional elimination step we are able to 
extend an equivalence relation to a conditional
equivalence relation that includes the set 
of consequences of the aforementioned common equations.
In a more general setting, we can specify an arbitrary
set of equations, or property, 
that are meant to enlarge the theory
to a temporal equivalence relation for 
specific purposes. To reuse the ExtendedExplain
procedure and associated lemmas, we replace the $common$
predicate for any predicate of interest.

In particular, given an equivalence relation 
$\mathcal{E}$, a 
set of Horn clauses $H$, and Horn clause $h$ 
of the form 
$\bigwedge (a_i = b_i) \rightarrow c = d$, we can 
find an explanation to the query 
$H \models_{\mathcal{E}} h$
by conditionally extending $H$ with the equations
from the antecedent of $h$ and then 
retrieving an explanation
of the membership of the consequent 
of $h$ in the conditional 
equivalence relation.

\begin{lemma}
  Let $H$ be a set of Horn clauses, $h$ a 
  Horn clause of the
  form $(\bigwedge_i a_i = b_i) \rightarrow c = d$, 
  $\mathcal{E}$ an equivalence relation between terms 
  of a language in EUF, and $\mathcal{E^{'}}$ the 
  associated temporal equivalence relation 
  obtained from extending
  $\mathcal{E}$ with the equations in the 
  antecedent of $h$.

  If there exists an explanation 
  $\mathfrak{p} := \{\mathfrak{a}_1 = \mathfrak{b}_1,
  \dots, \mathfrak{a}_n = \mathfrak{b}_n\}$ 
  for the query $H \models_{\mathcal{E^{'}}} c = d$,
  then the explanation $\mathfrak{p^{'}}$ for the query 
  $H \models_{\mathcal{E}} (\bigwedge_i a_i = b_i) 
  \rightarrow c = d$ is the subset of $\mathfrak{p}$
  that does not contain equations from 
  $\bigcup_{i=1}\{a_i = b_i\}$, i.e. the 
  explanation $\mathfrak{p^{'}}$ does not contain 
  the equations from the antecedent of the Horn clause
  $h$.

\end{lemma}

\begin{proof}
  If there exists an explanation $\mathfrak{p}$ for 
  $H \models_{\mathcal{E^{'}}} c = d$ then there exists 
  a proof tree with $c = d$ as root node and the equations
  from $\mathfrak{p}$ as leaves. 
  From lemma \ref{existence_horn_in_explain} and 
  the definition \ref{explain_def}
  we notice that $\mathfrak{p}$ only contains
  equations derived from $\mathcal{E}$ 
  and the antecedent of $h$. 

  Using the \emph{discharge
  rule} from basic propositional logic, i.e. 
  \begin{prooftree}
    \hypo[]{[A]}
    \ellipsis{}{B}
    \infer1{A \rightarrow B}
  \end{prooftree}
  , then we can obtain a proof tree with leaves
  only containing terms that do not belong to the antecedent 
  of $h$.

  Hence, the new proof tree will 
  have $(\bigwedge_{i=1}^m a^{'}_i = b^{'}_i) \rightarrow c = d$
  as root node and derived equations from $\mathcal{E}$
  as leaves, where $\{a^{'}_i = b^{'}_i\} \subseteq 
  antecedent(h)$ for each $1 \leq i \leq m$. 
  Thus, $\models antecedent(h) 
  \rightarrow a^{'}_i = b^{'}_i$ for each $1 \leq i \leq m$.
  Let $\mathfrak{p^{'}}$ be $\mathfrak{p} \setminus \bigcup_{i=1}^m\{a_i = b_i\}$.
  Therefore, by transitivity, we have that $\mathfrak{p^{'}}$
  is an explanation in $\mathcal{E}$ for $H \models_{\mathcal{E}}
  h$.

\end{proof}

The time complexity of this algorithm follows the reasoning as
the complexity analysis for the conditional congruence closure
algorithm previously proposed. If $n$ is the number of terms in
graph of terms and $m$ is the number of nodes in the graph 
representation of the Horn clauses $H$, then the algorithm 
runs in $\mathcal{O}((m + n) \log n)$ time.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
