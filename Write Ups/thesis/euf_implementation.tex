\section{Implementation}

The description of the interpolation algorithm presented in the
previous section suggests a straight forward implementation
of the first two stages using well-known algorithms 
\cite{10.1145/322186.322198,10.1145/322217.322228} 
and data structures from the SMT
solver Z3 \cite{10.1007/978-3-540-78800-3_24} to represent 
elements from the EUF language. One particular change was 
required in the congruence closure algorithm since Kapur's 
algorithm keeps common terms as representatives
whenever common terms belong to a partition of terms induced
by the equivalence relation.

The algorithm in \cite{10.1145/322217.322228}
uses a union-find data structure to encode the equivalence classes
of the nodes in the abstract syntax tree of the input formula with 
a `modify the smaller subtree' strategy. This means that
when two nodes $u, v$ in the abstract syntax tree are
meant to be merged, the representative of the new 
combined equivalence class is the node which has a bigger
numbers of predecessors nodes in the abstract
syntax tree pointing to the
equivalence class of the node. The idea was to update the least
amount of nodes that possibly can change representatives
due to the most recent merge operation of the equivalence classes 
and congruence.

\begin{notation}
  Given a theory $\mathcal{E}$ and a term $u$ in the language of 
  $\mathcal{E}$, we can indicate by $[u]$ the equivalence class
  induced by $\mathcal{E}$, i.e. $[u]_{\mathcal{E}} = \{ v \in TERMS | 
  \models_{\mathcal{E}} u = v\}$. \footnote{If the theory
    is clear from context, the notation $[u]$
  denotes the equivalence class of $u$.}
\end{notation}

Our algorithm uses a difference partial order to 
maintain common terms as representatives of 
the equivalence classes. The non-reflexive relation 
$\succ_{common}$ 
\footnote{The reflexive relation $u \succeq_{common} v$
  is defined as $u = v \lor u \succ_{common} v$, where
  the equality between nodes is defined as $|list(u)| = 
  |list(v)| \land u$ is a common term $\iff$ 
  $v$ is a common term.
}
is defined for all nodes $u, v$ in the abstract syntax 
tree of terms as:

\begin{equation*}
  u \succ_{common} v = \begin{cases} 
    |list(u)| > |list(v)| & \text{if }(u \text{ is a common term}\Leftrightarrow \\ 
    & v \text{ is a common term}) \\
    \text{u is a common term} & \text{otherwise}
  \end{cases}
\end{equation*}

where $list(u) = \{ f(u_1, \dots, u_n) \in \text{TERMS} 
| \exists i \in \{1, \dots, n\} \text{ such that } u_i \in [u] ] \}$

In the next section we will discuss the changes proposed to 
Phase III in Kapur's algorithm. 

\subsection{New conditional elimination 
step in Kapur's algorithm}

The modification of Phase III implemented in this thesis work
combines and extends the algorithms and data structures introduced
in \cite{GALLIER1987233, 10.1007/978-3-540-32033-3_33}.
The algorithm in \cite{GALLIER1987233} is a direct
extension of \cite{DOWLING1984267} which adapts a 
congruence closure algorithm from 
\cite{10.1145/322186.322198, 10.1145/322217.322228} in order
to update the union-find data structure maintaining the
equivalence relation between all the subterms in the input
formula. The implementation of the congruence closure
algorithm in \cite{10.1007/978-3-540-32033-3_33}
extends the usual $Find, Merge$ operations on the 
union-find data structure with the $Explain$ operator, 
which accomplishes the following:

\begin{itemize} \label{explain_def}
  \item[] $Explain(e, e^{'})$: if a sequence $U$ of
    unions of pairs $(e_1, e_1^{'}), \dots, (e_p, e_p^{'})$
    has taken place, it returns a minimal subset $E$
    of $U$ such that $(e, e^{'})$ belongs to the equivalence
    relationgenerated by $E$ and it returns $\bot$
    if no such $E$ exits.
\end{itemize}

The motivation behind the combination of 
Gallier's data structure and the congruence 
closure algorithm with explanations is twofold: 

\begin{itemize}
  \item[] 1. First, we want to introduce 
    common equations from the antecedents of 
    the Horn clauses obtained during Phase II
    to a conditional equivalence relation as well
    as updating the conditional equivalence relation 
    structure by using the equation propagation mechanism
    from the congruence closure algorithm and 
    the implicational propagation component 
    from Gallier's structure.
  \item[] 2. Additionally, we want to find all the common
    Horn clauses provable from the original input 
    of equations. The Explain operator in 
    \cite{10.1007/978-3-540-32033-3_33} is recursively 
    used to construct 
    the antecedent of such Horn clauses during the 
    conditional replacement step. The Explain operator 
    traverses a proof-tree data structure containing the nodes
    that were used to combine equivalence classes 
    in the underlying union-find data structure.
    Thus, the MERGE operation in \cite{GALLIER1987233} is
    required to update the proof tree 
    \footnote{This structure is used in order to retrieve
    explanations.}
    from \cite{10.1007/978-3-540-32033-3_33} as well.
\end{itemize}

The thesis work accomplishes the previous
points by implementing the following:

\begin{itemize}
  \item[] 1. In addition to the parsing procedure
    and initialization of the Gallier data structure,
    we assert into the union-find data structure 
    every common equation in the 
    antecedent of a Horn clause.
  \item[] 2. The implemented C++ class for 
    the congruence closure with explanation 
    \footnote{
      A fragment of the actual code is shown
      at Section \ref{congruence_closure_label}.
    } 
    includes a pointer as data member to the 
    class implementation
    for the Gallier data structure in order to propagate 
    the equational information achieved during
    merges and updates due to congruence. The modified 
    algorithms appears below in pseudo-code notation:

    \input{modified_unsatisfiability_testing_for_grounded_horn_clauses}
    \input{modified_congruence_closure_with_explanation_algorithms_merge}
    \input{modified_congruence_closure_with_explanation_algorithms_propagate}

  \item[] 3. We implement the ExtendedExplain 
    procedure which returns a list of common equations
    when an equation given as input is provable in the 
    conditional equivalence relation. The pseudo-code
    for the ExtendedExplain procedure is shown 
    below:

    \input{auxiliary_function_extended_explain}

\end{itemize}

\subsection{Invariants of the proposed
conditional elimination step}

We can prove that if a pair of terms $t_1, t_2$ belong
to the same equivalence class, then ExtendedExplain returns
a list of common equations 
using the axiomatization introduced in \ref{euf_axioms} as 
inference rules with the following lemmas:

\begin{lemma} \label{existence_horn_in_explain}
  Let $H$ be a set of Horn clauses produced by Phase II
  of Kapur's algorithm in some EUF language $\mathcal{L}$, 
  $\mathcal{E}$ the conditional 
  equivalence relation over the terms of 
  $\mathcal{L}$ produced by the above algorithm on $H$,
  and $t_1, t_2$ terms in 
  $\mathcal{L}$ such that
  $\models_{\mathcal{E}} t_1 = t_2$.
  If $\exists \text{ uncommon } a = b \in$
  $Explain(t_1, t_2)$, then $\exists h \in H$ such 
  that $h$ is of the form 
  $\bigwedge_i (c_i = d_i) \rightarrow a = b$.
\end{lemma}

\begin{proof}
  By the definition of the Explain operator in \ref{explain_def},
  we see that the Explain operator will return a
  list of all the asserted equations in the conditional
  equivalence relation. By inspection of the proposed
  algorithm, assertions into the conditional equivalence
  relation only happen in two places: when an equation 
  in the antecedent of a horn clause of $H$ is common, 
  and while updating the underlying union-find data structure
  when the $numargs$ field of a Horn clause becomes
  zero. The latter assert the consequent of such Horn clause.
  Since $u$ is not common, then such Horn clause 
  should exists in $H$.
\end{proof}

\begin{lemma}

  Let $H$ be a set of Horn clauses produced by Phase II
  of Kapur's algorithm in some EUF language 
  $\mathcal{L}$, $\mathcal{E}$ the conditional 
  equivalence relation over the terms of 
  $\mathcal{L}$ produced by the above algorithm on $H$,
  and $t_1, t_2$ terms in 
  $\mathcal{L}$ such that
  $\models_{\mathcal{E}} t_1 = t_2$.

  The list of equations returned by $ExtendedExplain(t_1, t_2, 
  H, \mathcal{E})$ contains only common equations.
\end{lemma}

\begin{proof} 
  If $t_1, t_2$ belong to the same equivalence relation,
  then there exists a closed derivation (proof tree) 
  with $t_1 = t_2$ as root node and the asserted
  equations introduced by the modified algorithm
  as leaves.

  The proof proceeds by induction on the complexity of the 
  derivation:

  \begin{itemize}
    \item Case: the last inference rule in the proof 
      tree was Reflexivity. The ExtendedExplain 
      algorithm returns an empty list. Thus, the
      statement is vacuously true.
    \item Case: the last inference rule in the proof 
      tree was Symmetry. Line 8 of ExtendedExplain
      returns a list of common equations $c$ and a list
      of uncommon equations $u$. 
      By Lemma \ref{existence_horn_in_explain}
      we see that there exists a Horn clause in $H$ for
      every uncommon equation in $u$. Line 9 of 
      ExtendedExplain applies recursively to each of 
      these equations. Since these equations belong
      to the conditional equivalence relation, there
      exists a derivation for the latter.
      By the inductive invariant, ExtendedExplain
      should return a list of common equation for 
      these subproofs. Thus, the final list contains
      only common equations.
    \item Case: the last inference rule in the proof 
      tree was Transitivity. The proof follows similarly
      to the previous case applied to the two subproofs
      for the Transitivity rule.
    \item Case: the last inference rule in the proof 
      tree was Congruence. The proof follwos similarly
      to the previous case applied $n$ times for each
      subproof in the Congruence rule.
  \end{itemize}
\end{proof}

\begin{corollary}
  Let $H$ be a set of Horn clauses produced by 
  Phase II of Kapur's algorithm, $\mathcal{E}$ the 
  equivalence relation obtained in Phase I of Kapur's 
  algorithm, and $\mathcal{E^{'}}$ the conditional 
  equivalence relation obtained after the modified
  conditional elimination algorithm. Then
  $H \models_{\mathcal{E^{'}}} a = b$ if and only if
  $\exists \text{ common } x \subseteq 
  \bigcup_{h \in H} antecedent(h)$ such that
  $H \models_{\mathcal{E}} \bigwedge x \rightarrow a = b$.
\end{corollary}

\subsection{New conditional replacement
step in Kapur's algorithm}

Once the conditional equivalence relation is built after 
the execution of the previous step, we can compute conditional eliminations
as follows. For the latter, we will require the following auxiliary functions:

\input{auxiliary_function_candidates}
\input{auxiliary_function_allcandidates}

By inspection is easy to notice that $Candidates$ 
and $allCandidates$ return a set of common terms and
a set of sets of common terms respectively.

The proposed conditional elimination step produces common Horn 
clauses from previous uncommon equations and uncommon Horn 
clauses obtained in Phase II of Kapur's algorithm.
The pseudo-code of the algorithms to 
process the original equations are shown below:

\input{conditional_elimination_part_1}
\input{conditional_elimination_part_2}

TODO: keep working here. Pay special attention to details of
the formalization.

\begin{lemma}
  Let $\{f(\mathfrak{a}_1, \dots, \mathfrak{a}_n) 
  = \mathfrak{a}\}$ be the set of equations produced
  in Phase I of Kapur's algorithms.
  Executing Conditional elimination only produces common 
  Horn clauses
\end{lemma}

TODO: fix vagueness in this paragraph.

In order to process Horn clauses obtained 
from Phase II of Kapur's algorithm, we apply 
the conditional elimination step for equation
over the equation in the a
At the end of this algorithm we can identify 
\emph{usable Horn clauses} by checking the Horn clauses
with \emph{numargs} entries equal to 0. 


The are two main invariants for the Horn clauses formed by the
conditional propagation procedure: 

\begin{itemize}
  \item the antecedents are constructed using the \emph{Explain} operator, 
    which returns a sequence of common equations since these are the 
    only merged terms added at the beginning of the initialization 
    routine of the modified Gallier's data structure.

    An additional property must be checked when processing previous
    Horn clauses. The `previous' antecedent for these clauses must be \emph{explainable},
    which means that every equation in the antecedent must belong to the conditional
    congruence closure, otherwise an empty explaination will be produced by the
    \emph{Explain} operator. If a Horn clause antecedent is not \emph{explainable}
    the resulting Horn clause cannot be added to the final result.

  \item the consequents are constructed with the help of the \emph{Candidates},
    \emph{AllCandidates}, and the \emph{CartesianProd} operators. 
    The former is a function that takes as input
    a term and returns a list of common terms
    that belong to the equivalence relation of a given term if such term is uncommon,
    and return a list containing the term itself if the term is common; the 
    \emph{AllCandidates} function takes as input a function application term and
    constructs a list of lists with common terms that are equivalent to the arguments
    of the function application if the function symbol is common, and returns an empty
    list otherwise; \emph{CartesianProd} implements a cartesian product, i.e. it 
    produces a list of n-tuples given as input a list of $n$ list of terms (the 
      composition of \emph{CartesianProd} and \emph{AllCandidates} are meant to be
    used to produce a function application free of uncommon terms). Finally, the
    head equations for the new Horn clauses are obtained by equating the left-hand
    side common candidates and right-hand side common candidates obtained by these 
    procedures.
\end{itemize}


\subsection{An extra application: Ground Horn Clauses with Explanations}

We notice that by adding common equations
from the antecedent of the Horn clauses during the 
conditional elimination step we are able to 
extend the equivalence relation to a conditional
equivalence relation that includes the set 
of consequences from the afore mentioned common equations.
In a more general setting we can specify arbitrarily the
set of equations that are meant to enlarge the theory
to a conditional equivalence relation for specific purposes.

In particular, given an equivalence relation $\mathcal{E}$, a 
set of Horn clauses $H$, and Horn clause $h$ of the form 
$\bigwegde (a_i = b_i) \rightarrow consequent$, we can 
provide an explanation to the query $H \models_{\mathcal{E}} h$
by conditionally extending $H$ with the equations
from the antecedent of $h$ and then retrieving an explanation
for the member of the consequent of $H$ in the conditional 
equivalence relation.

TODO: keep working here. Fill the missing details.
\begin{lemma}
  Let $H$ be blah blah blah
  Let $explanation := \{equation_1 \dots equation_n \}$ be the 
  explanation of $H \models_{\mathcal{E^{'}}} consequent$.
  The explanation for $H \models_{\mathcal{E}} antecedent 
  \rightarrow consequent$ is the subset of $explanation$
  that does not contain the equation from $antecedent$.
\end{lemma}

\begin{proof}
\end{proof} 

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
