\section{Implementation}

The description of the interpolation algorithm presented in the
previous section suggests a straight forward implementation
of the first two stages using well-known algorithms 
\cite{10.1145/322186.322198,10.1145/322217.322228} 
and data structures from the SMT
solver Z3 \cite{10.1007/978-3-540-78800-3_24} to represent 
elements from the EUF language. One particular changes was 
required in the congruence closure algorithm since Kapur's 
algorithm requires to keep common terms as representative
whenever common terms belong to a partition of terms induced
by the equivalence class.

Originally, the algorithm in \cite{10.1145/322217.322228}
uses a union-find data structure to encode the equivalence classes
of the nodes in the abstract syntax tree of the input formula with 
a `modify the smaller subtree' strategy. This means that
when two nodes $u, v$ in the abstract syntax tree are
meant to be merged, the representative of the new 
combined equivalence class is the node which has a bigger
numbers of predecessors nodes in the abstract
syntax tree pointing to the
equivalence class of the node. The idea was to update the least
amount of nodes that possibly can change representatives
due to the most recent merge operation of the equivalence classes 
and congruence.

Our algorithm uses a difference partial order to encode the 
requirement to maintain common terms as representatives of 
the equivalence class. The non-reflexive relation 
\footnote{the reflexive relation $u \succeq_{common} v$
  is defined as $u = v \lor u \succ_{common} v$ as
usual}
$\succ_{common}$ is defined for all nodes $u, v$ in the abstract syntax 
tree of terms as:

\begin{equation*}
  u \succ_{common} v = \begin{cases} 
  |list(repr(u))| > |list(repr(v))| & \text{if }u \text{ is a common term } \Leftrightarrow v \text{ is a common term} \\
  (\text{u is a common term}) & \text{otherwise}
    \end{cases}
\end{equation*}


TODO: keep working here

The thesis work considers the following
implementation for the rest of the stages of the algorithm.

\subsection{New optimized conditional elimination 
and replacement step in Kapur's algorithm}

The modification of Phase III implemented in this thesis work
combines and extends the algorithms and data structures introduced
in \cite{GALLIER1987233, 10.1007/978-3-540-32033-3_33}.

First, we explain a high level ideal on how 
we improve the \emph{conditional elimination}
step in Kapur's algorithm. We notice that this 
step \emph{propagates equationally} the
head equations of grounded Horn clauses with 
common antecedents. Initially we employ the
unsatisfiability algorithm for Horn clauses 
to achieve such propagation. However, the original
algorithm will not be enough because it will 
only propagate the head equation when all the
antecedents have truth value equal to 
true. To fix that problem, we modify two steps in Gallier's
algorithms:

\begin{itemize}
  \item When we build the data structure \emph{numargs} that keeps 
    track of the number of unproven
    equations in the antecedent of each Horn clause, we change 
    this number by the number
    of unproven uncommon equations in the antecedent of each 
    Horn clause. This will be useful
    because we only introduce head equations intro the queue 
    data structure in Gallier's algorithm
    when all the antecedents are true. With this 
    modification, our algorithm introduces head equations
    when all the antecedent equations are common. 
    Additionally the algorithm can still update
    correctly the truth value of common equations, 
    but these are not relevant for our propagation
    purposes.
  \item To guarantee that \emph{numargs} keeps the 
    right number of uncommon equations yet to
    be proven, we also modify the update mechanism for 
    \emph{numargs} in the main while loop of the algorithm.
    The original algorithm reduces by one the 
    corresponding entry in \emph{numargs}
    whenever a recently popped element from the queue 
    matches the antecedent of a Horn clause. We only
    decrease this value if such popped equation is uncommon. 
    This prevents the algorithm from accidentally
    reducing the number of uncommon equations yet to be proven, 
    which can cause that we propagate the
    uncommon head equation when the antecedent of a Horn 
    clause only consists of common equations.
\end{itemize}

At the end of this algorithm we can identify 
\emph{usable Horn clauses} by checking the Horn clauses
with \emph{numargs} entries equal to 0. Nonetheless, these 
Horn clauses are not the
desired \emph{usable Horn clauses} because the 
unsatisfiability testing algorithm
did not update the antecedents of the Horn clauses. 
The main difficulty to design a data structure
for the latter to work inside the unsatisfiability 
testing algorithm was the queue data structure
only adds grounded equation whenever the truth 
value of the literal changes to true, which happens
during \emph{equational propagation} or during 
the \emph{implicational propagation} steps.
For the \emph{implicational propagation} the task is 
easy because we can know the clause
where the just new proven ground equation comes, 
but it cannot be the same situation
for the \emph{equational propagation} since this 
step relies on congruence closure.

To remedy this issue, we equip our congruence closure 
algorithm with the Explanation operator, so
we can recover the grounded equations needed to entail 
any particular grounded equation. Additionally,
this will require a data structure to maintain the Horn 
clauses for each grounded equation that
it is the head equation of. With the latter we can 
recover the Horn Clauses where each grounded
equation came from to update the antecedents and 
obtain \emph{usable Horn clauses}.

The algorithm appears below in pseudo-code notation:

\begin{algorithm}[!ht]
  \caption{Modified Unsatisfiability Testing for Ground Horn Clauses}
  \linespread{\separationline}\selectfont
  \begin{algorithmic}[1]
    \Procedure {satisfiable}{var H : Hornclause; var queue, combine: queuetype; 
    var GT(H) : Graph; var consistent : boolean}
    \While {queue not empty and consistent}
    \State node := pop(queue);
    \For {clause1 in H[node].clauselist}
    \If {$\neg$ clause1.isCommon()}
    \State {numargs[clause1] := numargs[clause1] - 1}
    \EndIf
    \If {numargs[clause1] = 0}
    \State nextnode := poslitlist[clause1];
    \If {$\neg$ H[nextnode].val}
    \If {nextnode $\neq \bot$ }
    \State {queue := push(nextnode, queue);}
    \State {H[nextnode].val := true;}
    \State {u := left(H[nextnode].atom);} 
    \State {v := right(H[nextnode].atom);}
    \If {FIND(R, u) $\neq$ FIND(R, v)}
    \State {combine := push((u, v), combine);}
    \EndIf
    \Else
    \State {consistent := false;}
    \EndIf
    \EndIf
    \EndIf
    \EndFor
    \If {queue is empty and consistent}
    \State {closure(combine, queue, R);}
    \EndIf
    \EndWhile
    \EndProcedure
    \Statex
    \Procedure {closure}{var combine, queue : queuetype; 
    var R : partition}
    \While {combine is not empty}
    \State (u, v) = pop(combine)
    \State MERGE(R, u, v, queue)
    \EndWhile
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[!ht]
  \caption{Modified Congruence Closure with Explanation Algorithms - Merge}
  \linespread{\separationline}\selectfont
  \begin{algorithmic}[2]
    \Procedure {Merge}{R : partition, u, v : node; queue, combine : queuetype}
    \If {u and v are constants a and b}
    \State {add a = b to Pending;} 
    \State {Propagate();}
    \Else \Comment {u=v is of the form apply(a1, a2)=a}
    \If {Lookup(Representative(a1), Representative(a2)) is some apply(b1, b2)=b}
    \State {add (apply(a1, a2)=a, apply(b1, b2) = b) to Pending;} 
    \State {Propagate();}
    \Else
    \State {set Lookup(Representative(a1), Representative(a2)) to apply(a1, a2)=a;}
    \State {add apply(a1, a2)=a to UseList(Representative(a1)) and to UseList(Representative(a2));}
    \EndIf
    \EndIf
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[!ht]
  \caption{Modified Congruence Closure with Explanation Algorithms - Propagate}
  \linespread{\separationline}\selectfont
  \begin{algorithmic}[2]
    \Procedure {Propagate} {\text{ }}
    \While {Pending is non-empty}
    \State {Remove E of the form a=b or (apply(a1, a2) = a, apply(b1, b2) = b) from Pending}
    \If {$Representative(a) \neq Representative(b)$ and w.l.o.g. $|ClassList(Representative(a))| \leq |ClassList(Representative(b))|$}
    \State {oldReprA := Representative(a);}
    \State {Insert edge $a \rightarrow b$ labelled with E into the proof forest;}
    \For {each c in ClassList(oldReprA)}
    \State {set Representative(c) to Representative(b)}
    \State {move c from ClassList(oldReprA) to ClassList(Representative(b))}
    \For {each pointer L in ClassList(u)}
    \If {H[L].val = false}
    \State {set the field H[L].lclass or H[L].rclass pointed to by p to Representative(b)}
    \If {H[L].lclass = H[L].rclass}
    \State {queue := push(L, queue);}
    \State {H[L].val := true}
    \EndIf
    \EndIf
    \EndFor
    \EndFor
    \For {each apply(c1, c2) = c in UseList(oldReprA)}
    \If {Lookup(Representative(c1), Representative(c2)) is some apply(d1, d2) = d}
    \State {add (apply(c1, c2) = c, apply(d1, d2) = d) to Pending;}
    \State {remove apply(c1, c2) = c from UseList(oldReprA);}
    \Else
    \State {set Lookup(Representative(c1), Representative(c2)) to apply(c1, c2) = c;}
    \State {move apply(c1, c2) = c from UseList(oldReprA) to UseList(Representative(b));}
    \EndIf
    \EndFor 
    \EndIf
    \EndWhile
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\subsection{Ground Horn Clauses with Explanations}

We notice that, by removing our changes to the unsatisfiability testing
for grounded Horn clauses regarding uncommon symbols, we effectively combine
the congruence closure with explanations to the original unsatisfiability
testing algorithm. With the latter, we can query the membership of a Horn
clauses in a given user-defined theory and additionally obtain a proof of
the latter. This approach works by introducing the antecedent equations of
a grounded Horn clause as part of the user-defined theory in order to prove
its head equation. By the Deduction Theorem \cite{10.5555/1642730}, we can
recover a proof of the original queried Horn clause by removing the antecedent
equations appearing the proof given by the Explain operation.

\subsection{Conditional propagation in Kapur's algorithm}

Once the conditional congruence closure data structure is built after 
the execution of the previous step, we can compute conditional eliminations
as follows. For the latter, we will require the following auxiliary functions:

\begin{algorithm}[!ht]
  \caption{Auxiliary function - Candidates}
  \linespread{\separationline}\selectfont
  \begin{algorithmic}[2]
    \Procedure {Candidates} {z3::expr const \& t}
    \If {t is common}
    \State {\textbf{return} $\{ t \}$}
    \Else
    \State {\textbf{return} $\{ t^{'} | t^{'}  \in Class(t), t^{'} \text{is common} \}$}
    \EndIf
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[!ht]
  \caption{Auxiliary function - Auxiliar explain}
  \linespread{\separationline}\selectfont
  \begin{algorithmic}[2]
    \Procedure {Explain} {z3::expr const \& t1, z3::expr const \& t2}
    \State {z3::expr\_vector ans;}
    \If {t1.id() equals t2.id()}
    \State {\textbf{return} ans;}
    \EndIf
    \State {auto partial\_explain = hsat.equiv\_class.explain(t1, t2);} 
    \For {(auto const \& element : partial\_explain)}
    \If {element is common}
    \State {ans.push\_back(element);}
    \Else
    \State {auto const \& entry = hsat.head\_term\_indexer.find(equation.id());}
    \If {entry equals hsat.head\_term\_indexer.end()}
    \If {equation is common}
    \State {ans.push\_back(equation)};
    \EndIf
    \Else
    \For {(auto const \& hsat\_equation : entry $\rightarrow$ second $\rightarrow$ getAntecedent())}
    \State {ans.push\_back(hsat\_equation);}
    \EndFor
    \EndIf
    \EndIf
    \EndFor
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[!ht]
  \caption{Auxiliary function - allCandidates}
  \linespread{\separationline}\selectfont
  \begin{algorithmic}[2]
    \Procedure {allCandidates} {z3::expr const \& t}
    \If {t has f-symbol uncommon}
    \State {\textbf{return} $\{\{\}\}$;}
    \EndIf
    \If {t has f-symbol common and is of the form $f(t_1, \dots, t_n)$}
    \State {\textbf{return} $\{candidates(t_1), \dots, candidates(t_n)\}$;}
    \EndIf
    \If {t is a constant}
    \State {undefined}
    \EndIf
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[!ht]
  \caption{Conditional Elimination - Part 1}
  \linespread{\separationline}\selectfont
  \begin{algorithmic}[2]
    \Procedure {Conditional Elimination} {z3::expr const \& x, z3::expr const \& y}

    \If {x is constant and y is constant}
    \For {$\sigma_x$ in CANDIDATES(x)}
    \For {$\sigma_y$ in CANDIDATES(y)}
    \State {horn\_clause.add(EXPLAIN(x, $\sigma_x$) + EXPLAIN(y, $\sigma_y$), $\sigma_x = \sigma_y$)}
    \EndFor
    \EndFor
    \EndIf

    \If {x is constant and y is of the form $f_y(t_1^{'}, \dots, t_{k_2}^{'})$}
    \For {$\sigma_x$ in CANDIDATES(x)}
    \For {$\sigma_{f_y}$ in CANDIDATES($f_y(t_1^{'}, \dots, t_{k_2}^{'})$)}
    \State {horn\_clause.add(EXPLAIN(x, $\sigma_x$) + EXPLAIN($f_y(t_1^{'}, \dots, t_{k_2}^{'})$), $\sigma_y$), $\sigma_x = \sigma_{f_y}$}
    \EndFor
    \For {$arguments_{f_y}$ in CARTESIANPROD(ALLCANDIDATES($f_y(t_1^{'}, \dots, t_{k_2}^{'})$))}
    \State {horn\_clause.add(EXPLAIN(x, $\sigma_x$) + $\sum_{i=1}^{k_2}$ EXPLAIN($t_i^{'}$, $arguments_{f_y}[i]$), $\sigma_x = f_y(arguments_{f_y})$)}
    \EndFor
    \EndFor
    \EndIf

    \If {x is of the form $f_x(t_1, \dots, t_{k_1})$ and y is a constant}
    \State {\textbf{return} CONDITIONAL ELIMINATION(y, x);}
    \EndIf

    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[!ht]
  \caption{Conditional Elimination - Part 2}
  \linespread{\separationline}\selectfont
  \begin{algorithmic}[2]
    \Procedure {Conditional Elimination} {z3::expr const \& x, z3::expr const \& y}

    \If {x is of the form $f_x(t_1, \dots, t_{k_1})$ and y is of the form $f_y(t_1^{'}, \dots, t_{k_2}^{'})$}
    \For {$\sigma_{f_x}$ in CANDIDATES($f_x(t_1, \dots, t_{k_1})$)}
    \For {$\sigma_{f_y}$ in CANDIDATES($f_y(t_1^{'}, \dots, t_{k_2}^{'})$)}
    \State {horn\_clause.add(EXPLAIN($f_x(t_1, \dots, t_{k_1})$, $\sigma_{f_x}$) + EXPLAIN($f_y(t_1^{'}, \dots, t_{k_2}^{'})$), $\sigma_y$), $\sigma_{f_x} = \sigma_{f_y}$}
    \EndFor
    \For {$arguments_{f_y}$ in CARTESIANPROD(ALLCANDIDATES($f_y(t_1^{'}, \dots, t_{k_2}^{'})$))}
    \State {horn\_clause.add(EXPLAIN($f_x(t_1, \dots, t_{k_1})$, $\sigma_{f_x}$) + $\sum_{i=1}^{k_2}$ EXPLAIN($t_i^{'}$, $arguments_{f_y}[i]$), $\sigma_{f_x} = f_y(arguments_{f_y})$)}
    \EndFor
    \EndFor

    \For {$arguments_{f_x}$ in CARTESIANPROD(ALLCANDIDATES($f_x(t_1, \dots, t_{k_1})$))}
    \For {$\sigma_{f_y}$ in CANDIDATES($f_y(t_1^{'}, \dots, t_{k_2}^{'})$)}
    \State {horn\_clause.add($\sum_{i=1}^{k_1}$ EXPLAIN($t_i$, $arguments_{f_x}[i]$) + EXPLAIN($f_y(t_1^{'}, \dots, t_{k_2}^{'})$), $\sigma_y$), $f_x(arguments_{f_x}) = \sigma_{f_y}$}
    \EndFor
    \For {$arguments_{f_y}$ in CARTESIANPROD(ALLCANDIDATES($f_y(t_1^{'}, \dots, t_{k_2}^{'})$))}
    \State {horn\_clause.add($\sum_{i=1}^{k_1}$ EXPLAIN($t_i$, $arguments_{f_x}[i]$) + $\sum_{i=1}^{k_2}$ EXPLAIN($t_i^{'}$, $arguments_{f_y}[i]$), $f_x(arguments_{f_x}) = f_y(arguments_{f_y})$)}
    \EndFor
    \EndFor

    \EndIf

    \EndProcedure
  \end{algorithmic}
\end{algorithm}

The conditional propagation algorithm produces common Horn clauses from previous
uncommon equations and uncommon Horn clauses obtained in previous steps of Kapur's
algorithm. The are two main invariants for the Horn clauses formed by the
conditional propagation procedure: 

\begin{itemize}
  \item the antecedents are constructed using the \emph{Explain} operator, 
    which returns a sequence of common equations since these are the 
    only merged terms added at the beginning of the initialization 
    routine of the modified Gallier's data structure.

    An additional property must be checked when processing previous
    Horn clauses. The `previous' antecedent for these clauses must be \emph{explainable},
    which means that every equation in the antecedent must belong to the conditional
    congruence closure, otherwise an empty explaination will be produced by the
    \emph{Explain} operator. If a Horn clause antecedent is not \emph{explainable}
    the resulting Horn clause cannot be added to the final result.

  \item the consequents are constructed with the help of the \emph{Candidates},
    \emph{AllCandidates}, and the \emph{CartesianProd} operators. 
    The former is a function that takes as input
    a term and returns a list of common terms
    that belong to the equivalence relation of a given term if such term is uncommon,
    and return a list containing the term itself if the term is common; the 
    \emph{AllCandidates} function takes as input a function application term and
    constructs a list of lists with common terms that are equivalent to the arguments
    of the function application if the function symbol is common, and returns an empty
    list otherwise; \emph{CartesianProd} implements a cartesian product, i.e. it 
    produces a list of n-tuples given as input a list of $n$ list of terms (the 
      composition of \emph{CartesianProd} and \emph{AllCandidates} are meant to be
    used to produce a function application free of uncommon terms). Finally, the
    head equations for the new Horn clauses are obtained by equating the left-hand
    side common candidates and right-hand side common candidates obtained by these 
    procedures.

\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
