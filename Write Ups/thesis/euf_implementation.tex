\section{Implementation}

The description of the interpolation algorithm presented in the
previous section suggests a straight forward implementation
of the first two stages using well-known algorithms 
\cite{10.1145/322186.322198,10.1145/322217.322228} 
and data structures from the SMT
solver Z3 \cite{10.1007/978-3-540-78800-3_24} to represent 
elements from the EUF language. One particular change was 
required in the congruence closure algorithm since Kapur's 
algorithm keeps common terms as representatives
whenever common terms belong to a partition of terms induced
by the equivalence relation.

The algorithm in \cite{10.1145/322217.322228}
uses a union-find data structure to encode the equivalence classes
of the nodes in the abstract syntax tree of the input formula with 
a `modify the smaller subtree' strategy. This means that
when two nodes $u, v$ in the abstract syntax tree are
meant to be merged, the representative of the new 
combined equivalence class is the node which has a bigger
number of predecessors nodes in the abstract
syntax tree pointing to the
equivalence class of the node. The idea was to update the least
amount of nodes that possibly can change representatives
due to the most recent merge operation of the equivalence classes 
and congruence.

\begin{notation}
  Given a theory $\mathcal{E}$ and a term $u$ in the language of 
  $\mathcal{E}$, we can indicate by $[u]$ the equivalence class
  induced by $\mathcal{E}$, i.e. $[u]_{\mathcal{E}} = \{ v \in TERMS | 
  \models_{\mathcal{E}} u = v\}$. \footnote{If the theory
    is clear from context, the notation $[u]$
  denotes the equivalence class of $u$.}
\end{notation}

Our algorithm uses a difference partial order to 
maintain common terms as representatives of 
the equivalence classes. The non-reflexive relation 
$\succ_{common}$ 
\footnote{The reflexive relation $u \succeq_{common} v$
  is defined as $u = v \lor u \succ_{common} v$, where
  the equality between nodes is defined as $|list(u)| = 
  |list(v)| \land u$ is a common term $\iff$ 
  $v$ is a common term.
}
is defined for all nodes $u, v$ in the abstract syntax 
tree of terms as:

\begin{equation*}
  u \succ_{common} v = \begin{cases} 
    |list(u)| > |list(v)| & \text{if }(u \text{ is a common term}\Leftrightarrow \\ 
    & v \text{ is a common term}) \\
    \text{u is a common term} & \text{otherwise}
  \end{cases}
\end{equation*}

where $list(u) = \{ f(u_1, \dots, u_n) \in \text{TERMS} 
| \exists i \in \{1, \dots, n\} \text{ such that } u_i \in [u] ] \}$

In the next section we will discuss the changes proposed to 
Phase III in Kapur's algorithm. 

\subsection{New conditional elimination 
step in Kapur's algorithm}

The modification of Phase III implemented in this thesis work
combines and extends the algorithms and data structures introduced
in \cite{GALLIER1987233, 10.1007/978-3-540-32033-3_33}.
The algorithm in \cite{GALLIER1987233} is a direct
extension of \cite{DOWLING1984267} which adapts a 
congruence closure algorithm from 
\cite{10.1145/322186.322198, 10.1145/322217.322228} in order
to update the union-find data structure maintaining the
equivalence relation between all the sub-terms in the input
formula. The implementation of the congruence closure
algorithm in \cite{10.1007/978-3-540-32033-3_33}
extends the usual $Find, Merge$ operations on the 
union-find data structure with the $Explain$ operator, 
which accomplishes the following:

\begin{itemize} \label{explain_def}
  \item[] $Explain(e, e^{'})$: if a sequence $U$ of
    unions of pairs (previous Merge operations) 
    $(e_1, e_1^{'}), \dots, (e_p, e_p^{'})$
    has taken place, it returns a subset $E$
    of $U$ if $(e, e^{'})$ belongs to the equivalence
    relation generated by $E$ and it returns $\bot$
    otherwise.
\end{itemize}

If the EUF signature of the input 
equations does not contain functional symbols, 
the $Explain$ operation from \cite{10.1007/978-3-540-32033-3_33} 
returns the minimal subset of $E$. Nonetheless, such
assertion is not guaranteed when the signature
includes functional symbols.

The motivation behind the combination of 
Gallier's data structure and the congruence 
closure algorithm with explanations is twofold: 

\begin{itemize}
  \item[] 1. First, we want to introduce 
    common equations from the antecedents of 
    the Horn clauses obtained during Phase II
    to a conditional equivalence relation as well
    as updating the conditional equivalence relation 
    structure by using the equation propagation mechanism
    from the congruence closure algorithm and 
    the implicational propagation component 
    from Gallier's structure.
  \item[] 2. Additionally, we want to find all the common
    Horn clauses provable from the original input 
    of equations. The Explain operator in 
    \cite{10.1007/978-3-540-32033-3_33} is recursively 
    used to construct 
    the antecedent of such Horn clauses during the 
    conditional replacement step. The Explain operator 
    traverses a proof-tree data structure containing the nodes
    that were used to combine equivalence classes 
    in the underlying union-find data structure.
    Thus, the MERGE operation in \cite{GALLIER1987233} is
    required to update the proof tree 
    \footnote{This structure is used in order to retrieve
    explanations.}
    from \cite{10.1007/978-3-540-32033-3_33} as well.
\end{itemize}

The thesis work accomplishes the previous
points by implementing the following:

  1. In addition to the parsing procedure
    and initialization of the Gallier data structure,
    we assert into the union-find data structure 
    every common equation in the 
    antecedent of a Horn clause.

  2. The implemented C++ class for 
    the congruence closure with explanation 
    \footnote{
      A fragment of the actual code is shown
      at Section \ref{congruence_closure_label}.
    } 
    includes a pointer as data member to the 
    class implementation
    for the Gallier data structure in order to propagate 
    the equational information achieved during
    merges and updates due to congruence. The modified 
    algorithms appear below in pseudo-code notation:

    \input{modified_unsatisfiability_testing_for_grounded_horn_clauses}
    \input{modified_congruence_closure_with_explanation_algorithms_merge}
    \input{modified_congruence_closure_with_explanation_algorithms_propagate}

  3. We implemented the \emph{ExtendedExplain}
    procedure, which given as input an equation $a = b$ and a
    conditional equivalence relation $\mathcal{E}$ obtained
    from a set of equations and a set of Horn clauses
    in an EUF language $\mathfrak{L}$,
    it returns a list $C$ of common equations in $\mathfrak{L}$
    such that
    $\models_{\mathcal{E}} (\bigwedge_{h \in C} h) \rightarrow a = b$
    if the equation $a = b$ is belongs to the 
    conditional equivalence relation $\mathcal{E}$ ; 
    and it returns an empty list
    otherwise. 
    The pseudo-code
    for the ExtendedExplain procedure is shown 
    below:

    \input{auxiliary_function_extended_explain}


Using the modified Gallier algorithm for Unsatisfiability testing of
grounded Horn clauses endowed with the congruence
closure with explanations procedure we compute the conditional
congruence closure (Phase III of Kapur's algorithm) induced
by a set of Horn clauses $H$ as follows:

Conditional Congruence Closure Algorithm: \label{ccc_algorithm} \\
\begin{itemize} 
  \item[] Step 1. Let $\mathcal{E}$ be an empty equivalence class
    for all the terms in the term tree of the Horn clauses in $H$,
    i.e. there is an equivalence class for each term in $H$.

  \item[] Step 2. Insert all the Horn clauses in $H$ to the Gallier
    data structure and update $\mathcal{E}$ according to Gallier's
    algorithm.

  \item[] Step 3. For all the common equations $a = b$ 
    in the Horn clauses $h \in H$, Merge $a$ and $b$ in 
    $\mathcal{E}$. Update Gallier's data structure
    accordingly.

  \item[] Step 4. Return $\mathcal{E}$ as the conditional
    congruence closure for $H$.
\end{itemize}


We notice that the algorithm proposed to compute the 
conditional congruence closure does not call the Explain
operator of the Congruence Closure with Explanation since
the latter will be used to construct common Horn clauses
from induced conditional equivalence class. The Find and Merge
operation takes $\mathcal{O}(1)$ amortized cost. Thus, 
the amount of work related to the congruence closure
in the proposed algorithm take $\mathcal{O}(n \log n)$ time complexity
where $n$ denotes the number of equations in the graph term 
of the Horn clauses $H$.
However, the amount of work required by the \emph{unionupdate}
operation of Gallier data structure is $\mathcal{O}(
(2 m + n)\floor{n} + 1)$ where $m$ is the number of nodes 
in the graph representation of the Horn clauses $H$. In 
the worst-case scenario there can be at most $O(n^2)$
of these Horn clauses due to the Phase II of Kapur's algorithm.
Therefore, the time complexity of the conditional
congruence closure algorithm proposed is
$\mathcal{O}((m^2 + n)\log n)$.


Remark: the only equations asserted into the 
conditional equivalence class of the algorithm
above are only the common equations from 
antecedents in Horn clauses from $H$.

\subsection{Invariants of the proposed
conditional elimination step}

For the next lemmas, unless stated otherwise, let
$H$ be the Horn clauses obtained
after executing Phase II of Kapur's algorithm, and
$\mathcal{E}$ be the conditional equivalence class
computed by \ref{ccc_algorithm} using the Horn clauses
$H$.

We can prove that if the equation $t_1 = t_2$ belongs
to the conditional equivalence class $E$, 
then ExtendedExplain returns
a list of common equations $C$ such that
$\models_{\mathcal{E}} (\bigwedge_{h \in C} h) \rightarrow a = b$
using the axiomatization introduced in \ref{euf_axioms} as 
inference rules with the following lemmas:

\begin{lemma} \label{existence_horn_in_explain}
  Let $\mathcal{L}$ be some EUF language, 
  and $t_1, t_2$ terms in 
  $\mathcal{L}$ such that
  $\models_{\mathcal{E}} t_1 = t_2$.
  If $\exists \text{ uncommon } a = b \in$
  $Explain(t_1, t_2)$, then $\exists h \in H$ such 
  that $h$ is of the form 
  $\bigwedge_i (c_i = d_i) \rightarrow a = b$.
\end{lemma}

\begin{proof}
  By the definition of the Explain operator in \ref{explain_def},
  we see that the such operator will return a
  list of all the asserted equations in the conditional
  equivalence relation. By inspection of the proposed
  algorithm, assertions into the conditional equivalence
  relation only happen in two places: when an equation 
  in the antecedent of a horn clause of $H$ is common, 
  and while updating the underlying union-find data structure
  when the $numargs$ field of a Horn clause becomes
  zero. The latter assert the consequent of such Horn clause.
  Since $u$ is not common, then such Horn clause 
  should exist in $H$.
\end{proof}

\begin{lemma}\label{extended_explain_common_lemma}

  Let $\mathcal{L}$ be some EUF language 
  and $t_1, t_2$ terms in 
  $\mathcal{L}$ such that
  $\models_{\mathcal{E}} t_1 = t_2$.

  The list of equations returned by $ExtendedExplain(t_1, t_2, 
  H, \mathcal{E})$ contains only common equations.
\end{lemma}

\begin{proof} 
  If $t_1, t_2$ belong to the same equivalence relation,
  then there exists a closed derivation (proof tree) 
  with $t_1 = t_2$ as root node and the asserted
  equations introduced by the modified algorithm
  as leaves.

  The proof proceeds by induction on the complexity of the 
  derivation:

  \begin{itemize}
    \item Case 1. The last inference rule in the proof 
      tree was Reflexivity: The ExtendedExplain 
      algorithm returns an empty list. Thus, the
      statement is vacuously true.
    \item Case 2. The last inference rule in the proof 
      tree was Symmetry: Line 8 of ExtendedExplain
      returns a list of common equations $c$ and a list
      of uncommon equations $u$. 
      By Lemma \ref{existence_horn_in_explain}
      we see that there exists a Horn clause in $H$ for
      every uncommon equation in $u$. Line 9 of 
      ExtendedExplain applies recursively to each of 
      these equations. Since these equations belong
      to the conditional equivalence relation, there
      exists a derivation for the latter.
      By the inductive invariant, ExtendedExplain
      should return a list of common equation for 
      these subproofs. Thus, the final list contains
      only common equations.
    \item Case 3. The last inference rule in the proof 
      tree was Transitivity: The proof follows similarly
      to the previous case applied to the two subproofs
      for the Transitivity rule.
    \item Case 4. The last inference rule in the proof 
      tree was Congruence: The proof follows similarly
      to the previous case applied $n$ times for each
      subproof in the Congruence rule.
  \end{itemize}
\end{proof}

\begin{corollary} \label{commonantecedentcorollary}
  Let $H$ be a set of Horn clauses produced by 
  Phase II of Kapur's algorithm, $\mathcal{E}$ the 
  equivalence relation obtained in Phase I of Kapur's 
  algorithm, and $\mathcal{E^{'}}$ the conditional 
  equivalence relation obtained after the modified
  conditional elimination algorithm. Then
  $H \models_{\mathcal{E^{'}}} a = b$ if and only if
  $\exists \text{ common } x \subseteq 
  \bigcup_{h \in H} antecedent(h)$ such that
  $H \models_{\mathcal{E}} \bigwedge x \rightarrow a = b$.
\end{corollary}

\begin{example}
  Let us consider the input equations $\{
    1. f(f(x)) = f(x), \\ 2. x = f(f(x)), 
  3. f(a) \neq a\}$ 
  with the 
  set of symbols to eliminate to be 
  $\{ f \}$.
  Flattening introduces the following
  new equisatisfiable equations:
  $\{4. f(x) = e_1, 5. f(e_1) = e_2, 
    5. f(a) = e_3, 6. x = e_2, 7. e_2 = e_1, 
  8. e_3 = a \rightarrow \bot \}$. 
  Phase II introduces the following 
  Horn clauses $H$:
  $\{9. x = e_1 \rightarrow e_1 = e_2,
    10. x = a \rightarrow x = e_3,
    11. e_1 = a \rightarrow e_2 = e_3
  \}$.

  Our algorithm notices that Horn clause 10.
  contains only common equations in the
  antecedent. Hence, $x = a$ is added to the
  conditional congruence closure $\mathcal{E}$.
  With the latter $x = e_3$ is also added by
  the \emph{numargs} of Horn clause 10 reaches
  0. By transitivity, our algorithm
  includes $e_3 = a$ since both $x = e_3,
  x = a$ belong to $\mathcal{E}$.
  The last equation decreases the 
  \emph{numargs} entry of the Horn clause
  8. Thus, $\bot$ in $\mathcal{E}$.

  Using ExtendedExplain, we can compute the
  common antecedent $x$ 
  for the Horn clause in Corollary
  \ref{commonantecedentcorollary} using 
  ExtendedExplain as follows:

  \begin{itemize}
    \item $ExtendedExplain(e_3 = a) \rightarrow \bot$
    \item $\bigwedge \{ExtendedExplain(x = e_3), ExtendedExplain(x = a)\} \rightarrow \bot$, since
      $x = e_3$ was added to
      $\mathcal{E}$ by the congruence closure, $x = a$ was added to 
      $\mathcal{E}$ at the beginning of the algorithm because it is
      a common equation in the antecedent of a Horn clause in $H$,
      and $Explain(e_3 = a) = \{x = e_3, x = a\}$
    \item $\bigwedge(\{x = a\} \cup \{x = a\}) \rightarrow \bot$, 
      since $Explain(x = e_3) = \{x = a\}$
    \item $x = a \rightarrow \bot$, after simplification
  \end{itemize}

  \end{example}

  \subsection{New conditional replacement
  step in Kapur's algorithm}

  Once the conditional equivalence relation is built after 
  the execution of the previous step, we can compute conditional
  replacements as follows. For the latter, we will require 
  the following auxiliary functions:

  \input{auxiliary_function_candidates}
  \input{auxiliary_function_allcandidates}

  By inspection is easy to notice that $Candidates$ 
  and $allCandidates$ return a set of common terms and
  a set of sets of common terms respectively.

  The proposed conditional replacement step produces common Horn 
  clauses from previous uncommon equations and uncommon Horn 
  clauses obtained in Phase II of Kapur's algorithm.
  The pseudo-code of the algorithms to 
  process the original equations are shown below:

  \input{conditional_replacement_part_1}
  \input{conditional_replacement_part_2}

  \begin{lemma} \label{conditional_replacement_lemma}
    Let $Eqs := \{f(\mathfrak{a}_{i, 1}, \dots, \mathfrak{a}_{i, n}) 
    = \mathfrak{a}_i\}$ be the set of equations produced
    in Phase I of Kapur's algorithms, $H$ the set of 
    Horn clauses obtained in Phase II, and $\mathcal{E^{'}}$ the 
    conditional equivalence
    relation obtained by the proposed conditional replacement
    step.
    Executing the proposed conditional replacement step
    on $Eqs, H, \mathcal{E}$ produces common Horn clauses.
  \end{lemma}

  \begin{proof}
    By inspecting the conditional replacement algorithm 
    in \ref{conditional_replacement_part_1_impl},
    we noticed the antecedents of the Horn clauses 
    constructed are obtained using the ExtendedExplain 
    procedure, which from lemma \ref{extended_explain_common_lemma} 
    it produces a list of only common equations.

    Additionally, the equations in the consequent part 
    of the Horn clauses produced in the conditional replacement 
    procedure are of the form:

    \begin{itemize}
      \item $\sigma_x = \sigma_y$, 
        where $\exists t_1, t_2 \in TERMS$
        such that $\sigma_x \in Candidates(t_1)$ and 
        $\sigma_y \in Candidates(t_2)$
      \item $\sigma_x = f(arguments_{f})$, 
        where $\exists t, f(t_1, \dots, t_n) \in TERMS$
        such that $\sigma_x \in Candidates(t)$ and
        $f(arguments_f) \in \{f(\hat{t_1}, \dots, \hat{t_n})
          | \text{ f is a common functional symbol },
          \hat{t_i} \in Candidates(t_i) \text{ for } 1 \leq i \leq n
        \}$
      \item $f_x(arguments_x) = f_y(arguments_y)$, using the same
        definition for $f(arguments_f)$ from previous item
    \end{itemize}

    It is easy to see that the above equations are common if any
    of the involved sets are not empty. Therefore, the algorithm 
    only produces common Horn clauses.
  \end{proof}

  In order to process Horn clauses obtained 
  from Phase II of Kapur's algorithm, we apply 
  the conditional replacement step for equations
  over the equations in the consequent of all 
  the Horn clauses which $numargs$ entries are 
  equal to 0.

  \begin{lemma}
    Let $H$ be the set of Horn clauses
    obtained at the end of Phase II of Kapur's 
    algorithm with $numargs$ entry equal to 0 
    and $\mathcal{E^{'}}$ the associated
    conditional equivalence relation obtained 
    at the end of the conditional elimination 
    procedure. 
    If $h \in H$ is of the form $\bigwedge_i (a_i = b_i) 
    \rightarrow c = d$, then the Horn clauses
    $\{\bigwedge_i ExtendedExplain(a_i, b_i, H, \mathcal{E^{'}})
      \rightarrow h^{'}  | 
      h^{'} \in 
    ConditionalReplacement(c, d, H, \mathcal{E^{'}})\}$
    are common Horn clauses.
  \end{lemma}

  \begin{proof}
    We observe that if the $numargs$ entry of a Horn clause
    $h \in H$ is equal to 0, then 
    all the equations in the antecedent of $h$ belong 
    to the conditional equivalence relation. Thus, 
    there exists a proof in $\mathcal{E^{'}}$ for
    each of these equations. From the latter, the consequent
    of $h$ also belongs to the conditional equivalence
    relation. Using Lemmas \ref{extended_explain_common_lemma}
    and \ref{conditional_replacement_lemma} we can conclude that
    the Horn clause in the statement is a common Horn clause.
  \end{proof}

  \subsection{An additional application: checking
    membership of ground Horn clauses 
  with Explanations}

  By adding common equations
  from the antecedent of the Horn clauses during the 
  conditional elimination step we are able to 
  extend an equivalence relation to a conditional
  equivalence relation that includes the set 
  of consequences of the aforementioned common equations.
  In a more general setting, we can specify an arbitrary
  set of equations, or property, 
  that are meant to enlarge the theory
  to a conditional equivalence relation for 
  specific purposes. To reuse the ExtendedExplain
  procedure and associated lemmas, we replace the $common$
  predicate for any predicate of interest.

  In particular, given an equivalence relation $\mathcal{E}$, a 
  set of Horn clauses $H$, and Horn clause $h$ of the form 
  $\bigwedge (a_i = b_i) \rightarrow c = d$, we can 
  find an explanation to the query $H \models_{\mathcal{E}} h$
  by conditionally extending $H$ with the equations
  from the antecedent of $h$ and then retrieving an explanation
  of the membership of the consequent of $h$ in the conditional 
  equivalence relation.

  \begin{lemma}
    Let $H$ be a set of Horn clauses, $h$ a Horn clause of the
    form $(\bigwedge_i a_i = b_i) \rightarrow c = d$, 
    $\mathcal{E}$ an equivalence relation between terms 
    of a language in EUF, and $\mathcal{E^{'}}$ the associated
    conditional equivalence relation obtained from extending
    $\mathcal{E}$ with the equations in the antecedent of $h$.

    If there exists an explanation 
    $\mathfrak{p} := \{\mathfrak{a}_1 = \mathfrak{b}_1,
    \dots, \mathfrak{a}_n = \mathfrak{b}_n\}$ 
    for the query $H \models_{\mathcal{E^{'}}} c = d$,
    then the explanation $\mathfrak{p^{'}}$ for the query 
    $H \models_{\mathcal{E}} (\bigwedge_i a_i = b_i) 
    \rightarrow c = d$ is the subset of $\mathfrak{p}$
    that does not contain equations from 
    $\bigcup_{i=1}\{a_i = b_i\}$, i.e. the 
    explanation $\mathfrak{p^{'}}$ does not contain 
    the equations from the antecedent of the Horn clause
    $h$.

  \end{lemma}

  \begin{proof}
    If there exists an explanation $\mathfrak{p}$ for 
    $H \models_{\mathcal{E^{'}}} c = d$ then there exists 
    a proof tree with $c = d$ as root node and the equations
    from $\mathfrak{p}$ as leaves. 
    From lemma \ref{existence_horn_in_explain} and 
    the definition \ref{explain_def}
    we notice that $\mathfrak{p}$ only contains
    equations derived from $\mathcal{E}$ 
    and the antecedent of $h$. 

    Using the \emph{discharge
    rule} from basic propositional logic, i.e. 
    \begin{prooftree}
      \hypo[]{[A]}
      \ellipsis{}{B}
      \infer1{A \rightarrow B}
    \end{prooftree}
    , then we can obtain a proof tree with leaves
    only containing terms that do not belong to the antecedent 
    of $h$.

    Hence, the new proof tree will 
    have $(\bigwedge_{i=1}^m a^{'}_i = b^{'}_i) \rightarrow c = d$
    as root node and derived equations from $\mathcal{E}$
    as leaves, where $\{a^{'}_i = b^{'}_i\} \subseteq 
    antecedent(h)$ for each $1 \leq i \leq m$. 
    Thus, $\models antecedent(h) 
    \rightarrow a^{'}_i = b^{'}_i$ for each $1 \leq i \leq m$.
    Let $\mathfrak{p^{'}}$ be $\mathfrak{p} \setminus \bigcup_{i=1}^m\{a_i = b_i\}$.
    Therefore, by transitivity, we have that $\mathfrak{p^{'}}$
    is an explanation in $\mathcal{E}$ for $H \models_{\mathcal{E}}
    h$.

  \end{proof}

  The time complexity of this algorithm follows the reasoning as
  the complexity analysis for the conditional congruence closure
  algorithm previously proposed. If $n$ is the number of terms in
  graph of terms and $m$ is the number of nodes in the graph 
  representation of the Horn clauses $H$, then the algorithm 
  runs in $\mathcal{O}((m + n) \log n)$ time.
  
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
