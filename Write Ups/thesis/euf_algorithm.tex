\section{Algorithm}

Kapur's interpolation algorithm for the EUF theory uses quantifier-elimination
techniques to remove symbols in the first formula of an interpolation problem instance
that are not common with the second formula of the latter. 
Hence, the input for this algorithm is a conjunction of equalities in the
EUF theory and a set of symbols to eliminate, also unknown as uncommon symbols.

The steps/ideas in Kapur's algorithm for interpolant generation for the EUF theory
are the following:

\begin{itemize}
\item \textbf{Elimination of uncommon terms using congruence closure}.
  This step builds an equivalence
  relation using the input of the algorithm such that the representatives are common terms
  whenever possible. Let \emph{answer} be a variable denoting the 
  conjunction of all the input formulas
  which uncommon subterms are replaced by their representatives.
  If all the representatives in the equivalence relation are common terms, return \emph{answer}
  as the interpolant. Otherwise, continue with the following step.
\item \textbf{Horn clause generation by exposure}. This step uses Ackermann's 
  reduction \cite{10.5555/1391237}
  to produce Horn clauses to eliminate uncommon terms identifying two cases:
  \begin{itemize}
  \item The term is uncommon because the function symbol is uncommon.
  \item The term is uncommon because at least one of its arguments is
    an uncommon term.
  \end{itemize}
  Conjunct to \emph{answer} the conjunction of all these Horn Clauses.
  If all the Horn Clauses above are common, return \emph{answer} as the interpolant.
  Otherwise, continue with the following step.
\item \textbf{Conditional elimination}. Since some of the Horn clauses produced by
  the previous step are not common, we identify the Horn clauses that have
  \emph{common antecedents} and head equation with at least one uncommon term. For each
  of these Horn clauses, replace the uncommon term in its head by the common term in its head
  in the rest of the Horn Clauses, and include its antecedent 
  to the antecedent of such Horn clauses.
  We can see that this step reduces the number of uncommon 
  terms in the equalities of
  the Horn Clauses. We repeat this step until it cannot 
  be performed. At the end, we take only the
  set of Horn Clauses that have common antecedents 
  and have one uncommon term in its head. The call these
  Horn clauses \emph{useful Horn clauses}. Continue with the next step.
\item \textbf{Conditional replacement}. Using the \emph{useful Horn clauses} 
  generated in the previous
  step, update \emph{answer} to be the formula resulting 
  after \emph{conditionally replacing}
  uncommon terms in each equation of \emph{answer} by an 
  appropriate common term in the head of
  a \emph{useful Horn clauses}.
  To be more precise, let $\bigwedge_i a_i = b_i \rightarrow u \mapsto c$ 
  be a useful Horn clause,
  where the antecedent is a conjunction of common grounded equations, 
  $u$ is an uncommon term,
  and $c$ is a common term.
  Then for every instance of $u$ in each equation of \emph{answer}, conditionally replace $u$
  by $c$ under $\bigwedge_i a_i = b_i$.
  We notice that equations in \emph{answer}  of the previous step will become Horn Clauses with
  less uncommon terms. For completeness, we perform these replacements zero or more times
  (up to the maximal number of instances per equation) in order to leave space for other
  \emph{useful Horn Clauses} to replace the uncommon term in their heads as well.
  Remove all the literals in the current \emph{answer} that contain 
  uncommon terms and return this as the interpolant.
\end{itemize}

If the user is not interested in an explicit interpolant, 
we can present the \emph{usable Horn
  clauses} in a proper order such that the replacements 
  can be done without exponentially increasing
the size of the interpolant. This representation 
is useful because it provides a more compact
representation of the interpolant that the user 
might be able quicker to obtain.
Additionally, the user might be just 
interested in a particular subformula of 
the interpolant, so the
latter representation offers such feature.

This algorithm allows a flexible implementation 
which can lead several optimizations
based on the nature and applications of the 
interpolant.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
