\section{Kapur's Uniform Interpolation Generation \\ 
Algorithm for EUF}

Kapur's uniform interpolation algorithm for the 
EUF theory uses quantifier elimination
techniques to remove symbols of a given formula.
The input problem is a conjunction 
of equalities and disequalities in the
EUF theory and a set of symbols to be eliminated from the 
input formula, denoted
as uncommon symbols from the context of interpolation.
In preparation to discuss Kapur's algorithm we need to 
provide the 
following definitions.

\begin{definition} 
  Let $f$ be an $n-ary$ function symbol and $a_1, \dots, a_n,
  b$ terms from the EUF language. We say 
  \begin{equation*}
    f(a_1, \dots, a_n) = b
  \end{equation*}
  is an $f-equation$ if the terms $a_1, \dots, a_n, b$ are constants in
  the EUF language. We refer to the 
  outermost symbol of the $f-equation$
  as the function symbol appearing in such $f-equation$.
\end{definition}

$f-equations$ are used in Kapur's algorithm to simplify the 
structure of terms. 
As part of the input of Kapur's algorithm, there is a set
of uncommon symbols. The following definition extends 
the concept of uncommon symbols to uncommon terms.

\begin{definition}
  A term $t$ (resp. literal $L$) is $\cev{e}$-free 
  when there is no occurrence
  of variables to eliminate in $t$ (resp. $L$).

  Two flat terms $t, u$ of the form 
  \begin{equation*}
    t := f(a_1, \dots, a_n), u := f(b_1, \dots, b_n)
  \end{equation*}
  are said to be \emph{compatible} if and only if every $i = 1, \dots, n$, either
  $a_i$ is identical to $b_i$ or both $a_i$ and $b_i$ are $\cev{e}$-free.

  The \emph{difference set of two compatible terms} like 
  above is the
  set of dis-equalities $a_i \neq b_i$ such that 
  $a_i$ is not identical
  to $b_i$.
\end{definition}



\begin{definition}
  A term $t$ in the EUF language is \emph{uncommon} if:
  \begin{itemize}
    \item Case 1. $t$ is constant: $t$ is an uncommon term if
      $t$ as a symbol is uncommon
    \item Case 2. $t$ is a function application of the form 
      $f(t_1, \dots, t_n)$:
      $t$ is an uncommon term whenever $f$ is an uncommon 
      symbol or any $t_i$,
      where $1 \leq i \leq n$,
      is an uncommon term
  \end{itemize}

  Similarly, we can extend the notion of uncommon terms to uncommon 
  predicates in the EUF language as follows:

  \begin{itemize}
    \item Let $t_1, t_2$ be terms in the EUF language. $t_1 = t_2$,
      $t_1 \neq t_2$ are uncommon predicates if either $t_1$ or $t_2$
      are uncommon terms.
    \item Let $\psi, \varphi$ be predicates in the EUF language. 
      $\psi \star \varphi$ are uncommon predicates if either $\psi$
      or $\varphi$ are uncommon predicates where $\star \in \{ \land,
        \lor, \rightarrow \}$. 

  \end{itemize}
\end{definition}


A term (resp. predicate) which is not uncommon is a 
common term (resp. predicate).
Regarding extensions of the language with new constants, 
the \emph{common} property
is preserved under equalities. Formally, we mean the following:

\begin{definition}
  Let $\mathfrak{L}$ be a EUF language and $\mathfrak{a}$ a constant symbol
  not belonging to $\mathfrak{L}$. We say $\mathfrak{a}$ is a \emph{common constant under
  the theory $\mathcal{T}$ in the extended language $\mathfrak{L} \cup \{\mathfrak{a}\}$}
  if there exists a common term $t$ in the language $\mathfrak{L}$ such that 
  $\models_{\mathcal{T}} t = \mathfrak{a}$, otherwise $\mathfrak{a}$ is an \emph{
  uncommon constant}.
\end{definition}

A congruence closure algorithm is used in Kapur's algorithm
to keep track of representative terms \footnote{common terms
whenever it is possible.} in the equivalence class
induced by $f-equations$.
We introduce the following definition for notation purposes:

\begin{definition}
  Let $\mathcal{E}$ be an equivalence relation between grounded terms of some 
  language $\mathfrak{A}$. The function $repr_{\mathcal{E}} : \mathfrak{A} \rightarrow 
  \mathfrak{A} , repr_{\mathcal{E}} : a \mapsto b$  where $b$ is the representative
  element in $\mathcal{E}$ for $a$, i.e. $a \cong_{\mathcal{E}} b$.

\end{definition}

The interpolating formula produced by Kapur's algorithm is 
a conjunction of equations
and Horn clauses. A Horn clause is a disjunction of literals which 
contain at most
one non-negated literal. Using propositional logic, we can rewrite
Horn clauses into \emph{implication form} as follows:

\begin{table}[H]
  \centering
  \begin{tabular}{c|c|c}
    \toprule
    {} & Disjunction form & Implication form \\
    \toprule
    Definite clause & $\neg p_1 \lor \dots \lor \neg p_n \lor q$ & $p_1 \land \dots \land p_n \rightarrow q$ \\
    \midrule
    Fact & $p$ & $p$ \\
    \midrule
    Goal clause & $\neg p_1 \lor \dots \lor \neg p_n$ & $p_1 \land \dots \land p_n \rightarrow \bot$ \\
    \bottomrule
  \end{tabular}
\end{table}

For a Horn clause $h$,
we denote $antecedent(h)$ to be the conjunction of 
disequations in the disjunction of $h$ 
and $head(h)$ to be either the equation in the disjunction 
if such is present in $h$ 
or the particle $\bot$ otherwise.

Given an input formula $\psi$ of a conjunction of $n$ equalities and
disequalities in the EUF language and a set of symbols $U$ 
to be eliminated \footnote{Common and uncommon terms in the
description of the algorithm will be with respect to $U$}, 
the main steps in Kapur's algorithm for uniform 
interpolant generation for the EUF theory
are the following:

\begin{itemize}
  \item \textbf{Phase 0 - Flattening:} 
    For each sub-term $t$ in $\psi$, the algorithm assigns a 
    fresh unique constant $\mathfrak{a}_t$, replaces
    $t$ by $\mathfrak{a}_t$ in $\psi$, and 
    conjoins to $\psi$ new equations of the form:
    \begin{itemize}
      \item $c = \mathfrak{a}_c$, if $t$ is a constant $c$
      \item $f(\mathfrak{a}_{t_1}, \dots, \mathfrak{a}_{t_m}) 
        = \mathfrak{a}_{f(t_1, \dots, t_n)}$, if $t$ is a 
        function application of the form $f(t_1, \dots, t_m)$, 
        where $\mathfrak{a}_{t_i}$ is the constant introduced
        for the term $t_i$ for each $1 \leq i \leq m$
    \end{itemize}

    For all disequalities of the form
    $\mathfrak{a} \neq \mathfrak{b}$, the algorithm
    conjoins a Horn clause $\mathfrak{a} = \mathfrak{b} 
    \rightarrow \bot$ to $\psi$.

    Clearly, this step 
    generates $f-equations$ from equations in the input
    formula and Horn clauses
    from disequalities.
    The complexity time of this step is \bigO{n} since 
    flattening requires a linear scan of the input
    formula.

  \item \textbf{Phase I - Elimination of uncommon terms using 
    congruence closure:}

    This step builds an equivalence 
    relation $\mathcal{E}$ of the $f-equations$ introduced in the 
    Flattening step using a congruence closure algorithm such 
    that the representatives terms are common terms
    whenever possible. Uncommon terms appearing in 
    the current conjunction of 
    equations are replaced by their representatives.

    There are at most \bigO{n} $f-equations$, hence this step
    takes \bigO{n \log n} time to be accomplished.

  \item \textbf{Phase II - Horn clause generation by exposure:} 
    For all pairs of $f-equations$ in $\psi$ with identical 
    outermost symbol, i.e. of the
    $(f(\mathfrak{a}_1, \dots, \mathfrak{a}_m) = \mathfrak{c}, 
    f(\mathfrak{b}_1, \dots, \mathfrak{b}_m) = \mathfrak{d})$,
    this step conjoins to $\psi$ the following Horn clause 

    $\bigwedge_{i=1}^mrepr_{\mathcal{E}}(\mathfrak{a}_i)
    = repr_{\mathcal{E}}(\mathfrak{b}_i)
    \rightarrow
    repr_{\mathcal{E}}(\mathfrak{c}) 
    = repr_{\mathcal{E}}(\mathfrak{d})$

    when either of the following situations happen
    \footnote{Trivial equations in the antecedent
      of a Horn clause are removed; if the head equation 
      of Horn clause produced by this 
    step is trivial, then such Horn clause is discarded}:
    \begin{itemize}
      \item The outermost symbol of the $f-equations$ is an 
        uncommon symbol
      \item There is at least one constant argument in 
        any of the $f-equations$ 
        that is an uncommon constant
    \end{itemize}

    There are at most \bigO{n} $f-equations$, and the complexity
    time for each $repr_\mathcal{E}$ operation takes \bigO{1} 
    amortized time, thus
    this step requires \bigO{n^2} time. 

  \item \textbf{Phase III - Conditional elimination:} 
    The algorithm applies the following procedure to
    all the Horn clauses 
    $h := \bigwedge_i (c_i = d_i) \rightarrow a = b$
    in $\psi$ such that 
    $antecedent(h)$ is a common conjunction and 
    $head(h)$ is uncommon:

    \begin{itemize}
      \item if $a$ and $b$ are both uncommon terms:
        replace the equation $a = b$ appearing in the antecedents
        of all the current Horn clauses in $\psi$ 
        by $antecedent(h)$.
      \item if either $a$ is common and $b$ uncommon: 
        replace $b$ by $a$
        in all the current Horn clauses in $\psi$
        $h^{'}$ and append $antecedent(h)$ to 
        $antecedent(h^{'})$.
      \item if either $a$ is uncommon and $b$ common: 
        Proceed similarly as in the
        previous case.
    \end{itemize}

    We repeat this step until we cannot produce any new 
    Horn clauses. 

  \item \textbf{Phase IV - Conditional replacement:} 
    For each Horn clause in $\psi$ of the form 
    $\bigwedge_i(a_i = b_i) 
    \rightarrow u = c$ 
    where the antecedent is common, the term $u$ in its 
    head equation is an uncommon term,
    and the term $c$ is a common term,
    conjoin to $\psi$ a Horn clause for each 
    $f-equation$ $\phi$
    in $\psi$ containing $u$
    with 
    antecedent $\bigwedge_i a_i = b_i$ and head the 
    resulting equation from replacing $u$ by $c$
    in $\phi$.

    Return the conjunction of common formulas in $\psi$
    as the interpolant. This step together with 
    Phase III can take up
    to \bigO{2^n} time to be computed.
\end{itemize}

If the user is not interested in an explicit uniform interpolant, 
we can present a \textbf{lazy/} 
\textbf{pseudo uniform interpolant}, which is an ordered 
sequence of the original equations 
together with the Horn clauses produced in Phase II 
using an appropriate order between the uncommon terms.
Using this approach, the complexity time of Phase III
and Phase IV reduces to \bigO{n^2}.
In order to
provide a description of a procedure for the latter we need
to introduce the following definitions:

\begin{definition}\label{dep_pair}
  Let $\prec$ be a partial order between terms 
  such that $a \prec b$ whenever 
  $a$ is common and $b$ is uncommon. A \emph{dependency pair}
  for a Horn clause $h := \bigwedge_i (a_i = b_i) \rightarrow c = d$
  is a pair $(min(c, d, \prec), \{max(c, d, \prec)\} \cup \{ u | u$ 
  is an uncommon term appearing in antecedent(h) $\})$.
  The first element of a dependency pair is denoted as the
  target of $h$ and the second element the source of $h$.

  A \emph{valid dependency pair} is a dependency pair for some
  Horn clause $h$ which its target is not included in its
  source.
\end{definition}

We can notice from definition \ref{dep_pair} than even for 
equations, its source is never empty. 

\begin{definition}\label{dep_graph}
  Let $\prec$ be a partial order between terms 
  such that $a \prec b$ whenever 
  $a$ is common and $b$ is uncommon. Given a set of 
  Horn clauses $H$, a \emph{dependency graph for H}
  is the directed graph $G_H = (V, E)$ where
  \begin{itemize}
    \item $V := \{(target_i, source_i) | (target_i, source_i)$ 
      is a valid dependency pair from $H \}$
    \item $E := \{(target_i, source_i) \rightarrow (target_j, source_j) | 
        \{target_i\} \cup source_i \subseteq source_j
      \}$ 
  \end{itemize}
\end{definition}

Using \emph{valid dependency pairs} of the Horn clauses 
produced in Phase II
we can construct an acyclic directed graph as shown 
by the following theorem:

\begin{theorem}
  For any set of Horn clauses $H$, its dependency graph 
  never contains a cycle between its nodes.
\end{theorem}

\begin{proof}
  Suppose there exists a sequence of $n$ nodes such that 
  $(target_1, source_1) \rightarrow \dots 
  \rightarrow (target_n, source_n) \rightarrow (target_1, source_1)$.
  Since $\subseteq$ is transitive we can conclude that 
  $target_1 \in source_1$, which leads to a contradiction since all
  the nodes in a dependency graph are valid dependency pairs.
\end{proof}

Thus, given a set of Horn clauses $H$, we can compute its
dependency graph and use a topological sort algorithm to 
produce the ordered sequence required in a lazy uniform 
interpolant representation. 
Lazy uniform interpolants avoid the 
possible exponential size of the 
formal uniform interpolant. This presentation 
is useful because it provides a more compact
representation of the uniform interpolant that 
quicker to obtain.
Additionally, if the application of the uniform interpolant 
might focuses a particular sub-formula of 
the uniform interpolant, the
latter representation offers a way to quickly unravel 
the lazy uniform interpolant. This algorithm 
allows a flexible implementation 
which can lead several optimizations
based on the nature and applications of the uniform 
interpolant.

In order to work efficiently with Horn clauses 
during and after the conditional elimination step
in Kapur's algorithm, it was 
introduced in \cite{KAPUR2019} a 
\emph{conditional congruence closure} data structure as 
an extension of the congruence closure
generated by a conjunction of equalities.
This data structure includes Horn clauses in the set
of consequences of the theory induced by
the input formulas, allowing membership checking 
of Horn clauses as well. 

\begin{definition}
  Let $S$ be a set of equations in the EUF language
  $\mathfrak{L}$, and
  $CC(S)$ the set of consequences of $S$ using congruence
  closure. Then the \emph{conditional congruence closure of S},
  abbreviated as $CCC(S)$,
  is defined as follows:
  \begin{equation*}
    H \rightarrow a = b \in CCC(S) \text{ if and only if } 
    a = b \in CC(S \cup H)
  \end{equation*}

  where $H$ is a conjunction of equations in $\mathfrak{L}$ 
  and $a,b$ are terms in $\mathfrak{L}$.
\end{definition}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
