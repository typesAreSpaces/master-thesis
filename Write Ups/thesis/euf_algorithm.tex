\section{Kapur's Uniform Interpolation Generation Algorithm for EUF}

Kapur's interpolation algorithm for the EUF theory uses quantifier-elimination
techniques to remove symbols in the first formula of an inconsistent pair of formulas
that are not common with the second formula of the latter. 
Hence, the input for this algorithm is a conjunction of equalities in the
EUF theory and a set of symbols to eliminate, also known as uncommon symbols.
In preparation to discuss Kapur's algorithm we need to provide the 
following definitions.

\begin{definition} 
  Let $f$ be a $n-ary$ function symbol and $a_1, \dots, a_n,
  b$ terms from the EUF language. We say 
  \begin{equation*}
    f(a_1, \dots, a_n) = b
  \end{equation*}
  is an $f-equation$ if the terms $a_1, \dots, a_n, b$ are constants in
  the EUF language. We refer to the \emph{outermost symbol of the f-equation}
  as the function symbol appearing in such $f-equation$.
\end{definition}

$f-equations$ are used in Kapur's algorithm to simplify the structure of terms 
and in Phase II to expose hidden arguments and eliminate uncommon function symbols.

As part of the input of Kapur's algorithm, there is a set of uncommon symbols given 
directly or computed from the inconsistent pair of formulas by inspection. Using
these symbols we can define the following recursive definition of \emph{uncommon terms}:

\begin{definition}
  A term $t$ in the EUF language is \emph{uncommon} if:
  \begin{itemize}
    \item $t$ is an uncommon constant
    \item $t$ is a function application of the form $f(t_1, \dots, t_n)$
      where either $f$ is an uncommon symbol or any $t_i$ where $1 \leq i \leq n$ 
      is an uncommon term
  \end{itemize}

  Similarly, we can extend homomorphically the notion of uncommon terms to uncommon 
  predicates following a similar construction.

  \begin{itemize}
    \item Let $t_1, t_2$ be terms in the EUF language. $t_1 = t_2$,
      $t_1 \neq t_2$ are uncommon predicates if either $t_1$ or $t_2$
      are uncommon terms.
    \item Let $\psi, \varphi$ be predicates in the EUF language. 
      $\psi \star \varphi$ are uncommon predicates if either $\psi$
      or $\varphi$ are uncommon predicates where $\star \in \{ \land,
      \lor, \rightarrow \}$. $\neg \psi$ is an uncommon predicate if $\psi$
      is an uncommon predicate.

  \end{itemize}
\end{definition}


Regarding extensions of the language with new constants, the \emph{uncommon} property
is preserved under equalities. Formally, we mean the following:

\begin{definition}
  Let $\mathfrak{L}$ be a EUF language and $\mathfrak{a}$ a constant symbol
  not belonging to $\mathfrak{L}$. We say $\mathfrak{a}$ is a \emph{common constant under
  the theory $\mathcal{T}$ in the extended language $\mathfrak{L} \cup \{\mathfrak{a}\}$}
  if there exists a common term $t$ in the language $\mathfrak{L}$ such that 
  $\models_{\mathcal{T}} t = \mathfrak{a}$, otherwise $\mathfrak{a}$ is an \emph{
  uncommon constant}.
\end{definition}

Since congruence closure algorithms are revelant to Kapur's algorithm, we introduce the 
following definition for notation purposes:

\begin{definition}
  Let $\mathcal{E}$ be an equivalence relation between grounded terms of some 
  language $\mathfrak{A}$. The function $repr_{\mathcal{E}} : \mathfrak{A} \rightarrow 
  \mathfrak{A} , repr_{\mathcal{E}} : a \mapsto b$  where $b$ is the representative
  element in $\mathcal{E}$ for $a$.

\end{definition}

The interpolating formula produced by Kapur's algorith is a conjunction of equations
and Horn clauses. A Horn clause if a disjunction of literals which contain at most
one non-negated literal.
Due to its relevance in the procedure in the EUF theory, for a Horn clause $h$
we denote $antecedent(h)$ to be the conjuntion of disequations in the disjunction of $h$ 
and $head(h)$ to be either the equation in the disjunction if such is present in $h$ 
or the particle $\bot$ otherwise.

The main steps in Kapur's algorithm for interpolant generation for the EUF theory
are the following:

\begin{itemize}
  \item \textbf{Flattening:} 
    For each subterm $t$ in the input formula assign a fresh unique constant $\mathfrak{a}_t$. 
    Additionally, for each subterm $t$ generate new equations of the form:
    \begin{itemize}
      \item $c = \mathfrak{a}_c$, if $t$ is a constant $c$
      \item $f(\mathfrak{a}_{t_1}, \dots, \mathfrak{a}_{t_n}) 
        = \mathfrak{a}_{f(t_1, \dots, t_n)}$, if $t$ is a 
        function application of the form $f(t_1, \dots, t_n)$
    \end{itemize}
    Clearly, we can see that this step generates $f-equations$.
  \item \textbf{Elimination of uncommon terms using congruence closure:}
    This step builds an equivalence 
    relation $\mathcal{E}$ of the $f-equations$ introduced in the 
    Flattening step using a congruence closure algorithm such 
    that the representatives are common terms
    whenever possible. Uncommon terms appearing in the current conjunction of 
    equations are replaced by their representatives.
  \item \textbf{Horn clause generation by exposure:} 
    This step produces for all pairs of $f-equations$ 
    $(f(\mathfrak{a}_1, \dots, \mathfrak{a}_n) = \mathfrak{c}, 
    f(\mathfrak{b}_1, \dots, \mathfrak{b}_n) = \mathfrak{d})$
    Horn clauses of the form 
    $\bigwedge_{i=1}^n(repr_{\mathcal{E}}(\mathfrak{a}_i) = repr_{\mathcal{E}}(\mathfrak{b}_i))
    \rightarrow repr_{\mathcal{E}}(\mathfrak{c}) = repr_{\mathcal{E}}(\mathfrak{d})$
    when any of the two following situations happen \footnote{Trivial equations in the antecedent
    of a Horn clause are removed; if the head equation of Horn clause produced in this 
    step is trivial then such Horn clause is discarded}:
    \begin{itemize}
      \item The outermost symbol of the $f-equations$ is an uncommon symbol.
      \item There is at least one constant argument in any of the $f-equations$ 
        that is an uncommon constant.
    \end{itemize}
  \item \textbf{Conditional elimination:} 
    We identify the Horn clauses $h := \bigwedge_i (c_i = d_i) \rightarrow a = b$
    that have \emph{common antecedents} and uncommon head equations. 
    We perform the following procedure: 

    \begin{itemize}
      \item if $a$ and $b$ are both uncommon terms:
        replace the equation $a = b$ appearing in the antecedents
        of all the current Horn clauses by $antecedent(h)$.
      \item if either $a$ is common and $b$ uncommon: replace $b$ by $a$
        in all the current Horn clauses $h^{'}$ and append $antecedent(h)$ to 
        $antecedent(h^{'})$.
      \item if either $a$ is uncommon and $b$ common: Proceed similarly as in the
        previous case.
    \end{itemize}

    We repeat this step until we cannot produce any new Horn clauses. 

  \item \textbf{Conditional replacement:} 
    For each Horn clause of the form $\bigwedge_i(a_i = b_i) 
    \rightarrow u = c$ 
    where the antecedent is common, the term $u$ in its 
    head equation is an uncommon term,
    and the term $c$ is a common term, 
    replace every instance of $u$ appearing in each 
    $f-equation$ by $c$ to generate Horn clauses with 
    antecedent $\bigwedge_i a_i = b_i$.

    Return the conjunction of formulas obtained 
    as the interpolant.
\end{itemize}

If the user is not interested in an explicit interpolant, 
we can present a \textbf{lazy/pseudo interpolant}
which is an ordered sequence of the original equations 
together with the Horn clauses produced in Phase II 
using an appropriate order between the uncommon terms. In order to
provide a description of a procedure for the latter we need
to introduce the following definitions:

\begin{definition}\label{dep_pair}
  Let $\succ$ be a partial order between terms 
  such that $a \succ b$ whenever 
  $a$ is common and $b$ is uncommon. A \emph{dependency pair}
  for a horn clause $h := \bigwedge_i (a_i = b_i) \rightarrow c = d$
  is a pair $(min(c, d, \succ), \{max(c, d, \succ)\} \cup \{ u | u$ 
  is an uncommon term appering in antecedent(h) $\})$.
  The first element of a dependency pair is denoted as the
  target of $h$ and the second element the source of $h$.

  A \emph{valid dependency pair} is a dependency pair for some
  Horn clause $h$ which its target is not included in its
  source.
\end{definition}

We can notice from definition \ref{dep_pair} than even for 
equations, its source is never empty. 

\begin{definition}\label{dep_graph}
  Let $\succ$ be a partial order between terms 
  such that $a \succ b$ whenever 
  $a$ is common and $b$ is uncommon. Given a set of 
  Horn clauses $H$, a \emph{dependency graph for H}
  is the directed graph $G_H = (V, E)$ where
  \begin{itemize}
    \item $V := \{(target_i, source_i) | (target_i, source_i)$ 
      is a valid depency pair from $H \}$
    \item $E := \{(target_i, source_i) \rightarrow (target_j, source_j) | 
        \{target_i\} \cup source_i \subseteq source_j
      \}$ 
  \end{itemize}
\end{definition}

Using \emph{valid dependency pairs} of the Horn clauses 
produced in Phase II
we can construct an acyclic directed graph as shown 
by the following theorem:

\begin{theorem}
  For any set of Horn clauses $H$, its dependency graph 
  never contains a cycle between its nodes.
\end{theorem}

\begin{proof}
  Suppose there exists a sequence of $n$ nodes such that 
  $(target_1, source_1) \rightarrow \dots 
  \rightarrow (target_n, source_n) \rightarrow (target_1, source_1)$.
  Since $\subseteq$ is transitive we can conclude that 
  $target_1 \in source_1$, which leads to a contradiction since all
  the nodes in a dependency graph are valid depency pairs.
\end{proof}

Thus, given a set of Horn clauses $H$, we can compute its
dependency graph and use a topological sort algorithm to 
produce the ordered sequence required in the lazy interpolant
representation. Lazy interpolants avoid the 
possible exponential size of the 
formal interpolant. This representation 
is useful because it provides a more compact
representation of the interpolant that the user 
might be able quicker to obtain.
Additionally, the user might be just 
interested in a particular subformula of 
the interpolant, so the
latter representation offers such feature. This algorithm 
allows a flexible implementation 
which can lead several optimizations
based on the nature and applications of the 
interpolant.

In order to efficiently work with Horn clauses 
during and after the Conditional elimination step
in Kapur's algorithm, \cite{KAPUR2019} introduced 
\emph{conditional congruence closure} as 
an extension of the congruence closure
generated by a conjunction of equalities.
This structure includes Horn clauses in the set
of consequences of the theory induced by
the input formulas, allowing the membership checking 
of Horn clauses as well. 

\begin{definition}
  Let $S$ be a set of equations in the EUF language
  $\mathfrak{L}$, and
  $CC(S)$ the set of consequences of $S$ using congruence
  closure. Then the \emph{conditional congruence closure of S},
  abbreviated as $CCC(S)$,
  is defined as follows:
  \begin{equation*}
    H \rightarrow a = b \in CCC(S) \text{ if and only if } 
    a = b \in CC(S \cup H)
  \end{equation*}

  where $H$ is a conjunction of equations and $a,b$ terms in 
  $\mathfrak{L}$.
\end{definition}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
