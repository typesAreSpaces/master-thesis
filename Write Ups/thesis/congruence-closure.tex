\subsection{Congruence Closure}

The congruence closure problem consists of given a 
conjunction of equalities and disequalities $\psi$ 
determine if an equality $u = v$ follows from the 
consequence generated by $\models_{EUF} 
\psi$.

As noted in \cite{10.5555/1097042}, it is just succiffient
to compute the minimal relation containing the initial 
relation defined by the
equalities in $\psi$ closed under reflexivity, symmetry,
transitivity and congruence considering all the subterms
in the formulas $\psi$ and $u = v$.

The authors in \cite{10.1145/322217.322228, 
10.1145/322186.322198} independently formulated an optimized
version of the algorithm afore mentioned. Their key observation
was to introduce a list of pointers keeping track of the
antecedents nodes in the abstract syntax tree induced by
the formulas. The latter allows a fast signature checking
in order to determine if two nodes are equivalent under
the equivalence relation of the formulas. The algorithm
in \cite{10.1145/322217.322228} has better runtime
complexity \bigO{n \log n} since it also implements 
a `modify the smaller half' (using the union-find 
data structure). The congruence closure algorithm in 
\cite{10.1145/322217.322228} has a runtime complexity
of \bigO{n^2}. Nonetheless, the authors reported no 
significant advantage of the first approach
because, for verification purposes, the list of antecedents is
usually small. Both approaches provides the FIND, MERGE 
operations.

In \cite{10.1007/978-3-540-32033-3_33}, the authors 
introduced a Union-Find data structure that supports the 
additional 
Explanation operation. This operation receives as input 
an equation between constants. If the input equation is 
a consequence of the current equivalence relation defined 
in the Union Find data structure, the Explanation operation 
returns the minimal sequence of equations used to build 
such equivalence relation, otherwise it returns 
`Not provable'. A proper implementation of this algorithm 
extends the traditional Union-Find data structure with 
a \emph{proof-forest}, which consists of an additional 
representation of the underlying equivalence relation that 
does not compress paths whenever a call to the Find 
operation is made. For efficient reasons, the Find 
operation uses the path compression and weighted union.

The main observation in \cite{10.1007/978-3-540-32033-3_33} 
is that, in order to recover an explanation between 
two terms, by traversing the path between the two nodes 
in the proof tree, the last edge in the path guarantees to 
be part of the explanation. Intuitively, this follows 
because only 
the last Union operation was responsible of merging the 
two classes into one. Hence, we can recursively recover 
the rest of the explanation by recursively traversing 
the subpaths found.

Additionally, the authors in 
\cite{10.1007/978-3-540-32033-3_33} 
extended the Congruence Closure algorithm 
\cite{10.1007/978-3-540-39813-4_5} using the above data 
structure to provide Explanations for the theory of EUF.  
The congruence closure algorithm is a 
simplification of the congruence 
closure algorithm in \cite{10.1145/322217.322228}. The latter 
combines the traditional \emph{pending} and \emph{combine} list 
into one single list, hence removing the initial 
\emph{combination} loop in the algorithm in 
\cite{10.1145/322217.322228}.

The implementation work utilizes the latter congruence closure
with explanations for the interpolation algorithm of the 
theory EUF. The idea was to use the explanation operator
to construct uncommon-free Horn clauses.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
